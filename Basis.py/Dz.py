# Модуль 1 Введение в Python
# Тема: Алгоритмы. Часть 1









# Задание 1
# Написать в словесной форме и нарисовать блок-схему
# алгоритма управления автомобилем.







# Начало движения:
# Водитель заводит двигатель автомобиля.

# Включается передача (обычно первая, если автомобиль с механической коробкой передач, или положение "D" для автоматической коробки передач).

# Водитель снимает ручной тормоз (если он включен).

# Набор скорости:

# Водитель плавно нажимает на педаль газа для начала движения.

# По мере увеличения скорости водитель переходит на более высокие передачи (для механики) или передача автоматически меняется (для автомата).




# Оценка дорожной обстановки:
# Водитель постоянно отслеживает:

# Состояние дороги (сухая, мокрая, наличие препятствий).

# Текущую скорость автомобиля (через спидометр).

# Дорожные знаки и светофоры.

# Другие транспортные средства и пешеходов.



# Маневрирование:
# При необходимости смены полосы или поворота водитель включает соответствующий сигнал поворота.

# Водитель плавно поворачивает рулевое колесо в нужную сторону и корректирует траекторию движения.



# Торможение:
# При необходимости остановиться или снизить скорость водитель плавно нажимает на педаль тормоза.
# При полной остановке включается стояночный тормоз (если необходимо).


# Парковка:
# Водитель выбирает подходящее место для парковки.
# Плавно снижает скорость и останавливает автомобиль.
# Включает стояночный тормоз и выключает двигатель.



# Остановка и завершение движения:
# Водитель ставит автомобиль на стоянку, выключает двигатель и выходит из машины.
# Конец алгоритма.







# Блок-схема алгоритма управления автомобилем
# Блок-схема описывает последовательность действий водителя во время управления автомобилем.

# Начало ->
# Завести двигатель? (да/нет) ->
# Если "да": -
# Включить передачу ->
# Снять с ручного тормоза ->
# Нажать на газ ->
# Двигаться? (да/нет) ->
# Если "да": ->
# Оценить обстановку ->
# Маневрировать? (да/нет) ->
# Если "да": -> Включить сигнал поворота -> Повернуть -> Вернуться к оценке обстановки.
# Если "нет": -> Двигаться по прямой -> Вернуться к оценке обстановки.
# Тормозить? (да/нет) ->
# Если "да": -> Нажать на тормоз ->
# Остановиться? (да/нет) ->
# Если "да": -> Остановить автомобиль -> Поставить на стоянку -> Выключить двигатель -> Конец.
# Если "нет": -> Вернуться к оценке обстановки.










# Блок-схема алгоритма управления автомобилем
# +-----------------------------+
# |            Начало           |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | Завести двигатель? (да/нет) |
# +-------------+---------------+
#     |         |
#     |         v
#     |     +---+---+
#     |     |  Нет  |
#     |     +-------+
#     |         |
#     |         v
#     |     +-------+
#     |     | Конец |
#     |     +-------+
#     |
#     v
# +-------------+---------------+
# | Включить передачу           |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | Снять с ручного тормоза     |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | Нажать на газ                |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | Двигаться? (да/нет)         |
# +-------------+---------------+
#     |         |
#     |         v
#     |     +---+---+
#     |     |  Нет  |
#     |     +-------+
#     |         |
#     |         v
#     |     +-------+
#     |     | Конец |
#     |     +-------+
#     |
#     v
# +-------------+---------------+
# | Оценить обстановку          |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | Маневрировать? (да/нет)     |
# +-------------+---------------+
#     |         |
#     |         v
#     |     +---+---+
#     |     |  Нет  |
#     |     +-------+
#     |         |
#     |         v
#     |     +-------------+
#     |     | Двигаться по|
#     |     | прямой      |
#     |     +-------------+
#     |         |
#     |         v
#     |     +-------------+
#     |     | Вернуться к |
#     |     | оценке     |
#     |     | обстановки  |
#     |     +-------------+
#     |
#     v
# +-------------+---------------+
# | Включить сигнал поворота    |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | Повернуть                   |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
#  | Вернуться к оценке обстановки|
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | Тормозить? (да/нет)         |
# +-------------+---------------+
#     |         |
#     |         v
#     |     +---+---+
#     |     |  Нет  |
#     |     +-------+
#     |         |
#     |         v
#     |     +-------------+
#     |     | Вернуться к |
#     |     | оценке     |
#     |     | обстановки  |
#     |     +-------------+
#     |
#     v
# +-------------+---------------+
# | Нажать на тормоз            |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | Остановиться? (да/нет)     |
# +-------------+---------------+
#     |         |
#     |         v
#     |     +---+---+
#     |     |  Нет  |
#     |     +-------+
#     |         |
#     |         v
#     |     +-------------+
#     |     | Вернуться к |
#     |     | оценке     |
#     |     | обстановки  |
#     |     +-------------+
#     |
#     v
# +-------------+---------------+
# | Остановить автомобиль       |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | Поставить на стоянку       |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | Выключить двигатель        |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# |             Конец           |
# +-----------------------------+





# Фотография номер один в папке images 










# Задание 2
# Написать в словесной форме и нарисовать блок-схему
# алгоритма покупки велосипедных шин.







# Шаги алгоритма покупки велосипедных шин:
# Начало:
# Алгоритм начинается с того, что пользователь решает приобрести новые велосипедные шины.




# Определение потребности:
# Пользователь определяет, почему нужны новые шины (износ, прокол, улучшение качества или необходимость сменить сезонные шины).




# Измерение текущих параметров шин:
# Пользователь проверяет текущие параметры шин (размер, диаметр колеса, ширину и тип покрышек).
# Если пользователь не знает параметры, он может свериться с инструкцией велосипеда или текущими шинами.



# Выбор типа шин:
# Пользователь определяет, какой тип шин нужен:
# Гладкие для шоссе
# Широкие и зубчатые для горных дорог
# Устойчивые к проколам для городских поездок и т.д.



# Определение бюджета:
# Пользователь устанавливает бюджет на покупку шин, исходя из своих финансовых возможностей.




# Поиск шин в магазинах:
# Пользователь начинает искать шины в интернет-магазинах или физических магазинах, сверяя параметры шин с теми, которые нужны.





# Сравнение моделей и цен:
# Пользователь сравнивает несколько моделей шин с нужными характеристиками, анализируя цену, отзывы, и репутацию производителя.




# Принятие решения о покупке:
# Пользователь выбирает одну из шин, которая соответствует его критериям по цене, качеству и характеристикам.





# Оформление покупки:
# Пользователь переходит к оформлению заказа (выбирает способ оплаты, доставки и указывает адрес).





# Получение товара:
# Пользователь получает шины (в магазине или через доставку).





# Установка шин:
# После получения пользователь устанавливает новые шины на велосипед либо самостоятельно, либо в мастерской.


# Конец:






# Алгоритм завершен, пользователь может ездить на велосипеде с новыми шинами.
# Блок-схема алгоритма покупки велосипедных шин:
# Начало →
# Определить потребность в новых шинах →
# Проверить параметры текущих шин →
# Выбрать тип шин →
# Установить бюджет →
# Поиск в магазинах →
# Сравнить модели и цены →
# Выбрать подходящие шины →
# Оформить покупку →
# Получить товар →
# Установить шины →
# Конец










# Блок-схема алгоритма покупки велосипедных шин
#  +-----------------------------+
# |            Начало           |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | Определить потребность в    |
# | новых шинах                 |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | Проверить параметры текущих |
# | шин                         |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | Выбрать тип шин             |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | Установить бюджет           |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | Поиск в магазинах           |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | Сравнить модели и цены      |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | Выбрать подходящие шины     |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | Оформить покупку            |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | Получить товар              |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | Установить шины             |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# |             Конец           |
# +-----------------------------+











# Задание 3
# Написать в словесной форме и нарисовать блок-схему
# алгоритма написания романа.








# Идея: Определение главной темы, сюжета или идеи романа.

# На этом этапе автор решает, о чем будет роман, его жанр и главная идея.
# Создание персонажей: Разработка главных и второстепенных персонажей.

# Каждый персонаж получает свои черты, мотивацию, историю.
# Создание мира: Определение времени и места событий.

# Построение контекста: в каком мире живут персонажи и что окружает их.
# Планирование сюжета: Создание структуры сюжета.

# Определение основных событий, кульминации, развязки.
# Письмо первой черновой версии: Написание текста от начала до конца.

# Написание без исправлений и полной отшлифовки, с фокусом на общий ход повествования.
# Редактирование: Первичная правка написанного текста.

# Переписывание сцен, изменение диалогов, уточнение деталей.
# Получение обратной связи: Передача текста для рецензирования.

# Просмотр текста другими людьми или редактором для комментариев.
# Второе редактирование: Учет полученных комментариев и улучшение текста.

# Исправление недостатков, улучшение структуры и детализация.
# Финальная проверка: Проверка на наличие грамматических ошибок, недочетов.

# Проверка финального текста на отсутствие мелких ошибок.
# Публикация: Выпуск романа.

# Подготовка к публикации: выбор издателя, формат публикации.






# Блок-схема алгоритма написания романа
# +-----------------------------+
# | 1. Идея и концепция         |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 2. Исследование             |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 3. Создание персонажей      |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 4. Создание сюжета          |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 5. Создание мира            |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 6. Написание первой главы   |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 7. Написание последующих глав|
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 8. Поддержание темпа        |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 9. Первое редактирование    |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 10. Второе редактирование   |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 11. Третье редактирование   |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 12. Обратная связь          |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 13. Финальные правки        |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 14. Подготовка к публикации |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 15. Выбор способа публикации |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 16. Публикация              |
# +-------------+---------------+










# Задание 4
# Написать в словесной форме и нарисовать блок-схему
# алгоритма установки дверей.










# Шаг 1: Подготовка
# Подготовка инструментов и материалов: Убедитесь, что у вас есть все необходимые инструменты и материалы, такие как дверь,
# петли, шурупы, отвертка, уровень, рулетка, дрель и т.д.
# Проверка дверного проема: Убедитесь, что дверной проем соответствует размерам двери. При необходимости выполните подгонку.



# Шаг 2: Установка дверной коробки
# Сборка дверной коробки: Соберите дверную коробку по инструкции производителя.
# Установка коробки в проем: Установите дверную коробку в проем, используя уровень для проверки вертикальности и горизонтальности.
# Закрепление коробки: Закрепите коробку в проеме с помощью клиньев и шурупов. Проверьте еще раз уровень и при необходимости подкорректируйте.



# Шаг 3: Установка петель
# Разметка мест для петель: Разметьте места для установки петель на дверной коробке и на самой двери.
# Установка петель на дверь: Прикрепите петли к двери с помощью шурупов.
# Установка петель на коробку: Прикрепите петли к дверной коробке.



# Шаг 4: Установка двери
# Навешивание двери: Поднимите дверь и навесьте ее на петли. Проверьте, чтобы дверь открывалась и закрывалась без заеданий.
# Регулировка двери: При необходимости выполните регулировку двери, чтобы она ровно стояла в проеме и не касалась пола или коробки.



# Шаг 5: Завершение
# Установка замка и ручек: Установите замок и ручки на дверь, следуя инструкции производителя.
# Проверка работы: Проверьте работу замка и ручек, убедитесь, что все функционирует правильно.
# Финишная отделка: При необходимости выполните финишную отделку, такую как установка наличников и покраска.










# Блок-схема алгоритма установки дверей
# +-----------------------------+
# | 1. Подготовка инструментов  |
# |    и материалов             |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 2. Проверка дверного проема |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 3. Сборка дверной коробки   |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 4. Установка коробки в проем|
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 5. Закрепление коробки      |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 6. Разметка мест для петель |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 7. Установка петель на дверь|
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 8. Установка петель на      |
# |    коробку                  |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 9. Навешивание двери        |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 10. Регулировка двери       |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 11. Установка замка и ручек |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 12. Проверка работы          |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 13. Финишная отделка        |
# +-------------+---------------+








# Задание 5
# Написать в словесной форме и нарисовать блок-схему
# алгоритма управления скейтом.








# Шаг 1: Подготовка
# Подбор оборудования: Убедитесь, что у вас есть подходящий скейтборд и защитное снаряжение (шлем, наколенники, налокотники, перчатки).
# Проверка скейтборда: Проверьте состояние скейтборда, включая колеса, подвески и доску на наличие повреждений.



# Шаг 2: Начало движения
# Размещение на скейтборде: Поставьте одну ногу на переднюю часть скейтборда, а другую на землю для отталкивания.
# Отталкивание: Оттолкнитесь ногой от земли, чтобы начать движение. После набора скорости поставьте отталкивающую ногу на заднюю часть скейтборда.



# Шаг 3: Управление движением
# Поддержание равновесия: Слегка согните колени и держите тело расслабленным для лучшего контроля и баланса.
# Повороты: Для выполнения поворота наклоните тело в нужную сторону. Давите на края доски ногами, чтобы изменить направление движения.
# Торможение: Для торможения используйте одну из техник:
# Нога на землю: Слегка поставьте заднюю ногу на землю и постепенно увеличивайте давление, чтобы замедлить движение.
# Тейл-драг: Нажмите на хвост доски задней ногой, чтобы он коснулся земли и замедлил движение.



# Шаг 4: Завершение движения
# Остановка: Полностью остановитесь, поставив обе ноги на землю.
# Проверка оборудования: После катания проверьте состояние скейтборда на наличие повреждений.










# Блок-схема алгоритма управления скейтом
# +-----------------------------+
# | 1. Подбор оборудования      |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 2. Проверка скейтборда      |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 3. Размещение на скейтборде |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 4. Отталкивание              |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 5. Поддержание равновесия   |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 6. Повороты                  |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 7. Торможение                |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 8. Остановка                 |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 9. Проверка оборудования    |
# +-------------+---------------+








# Задание 6
# Написать в словесной форме и нарисовать блок-схему
# алгоритма мытья посуды.







# Шаг 1: Подготовка
# Сортировка посуды: Разделите посуду на категории: тарелки, чашки, столовые приборы, кастрюли и сковородки.
# Удаление остатков пищи: Удалите крупные остатки пищи с посуды, используя бумажные полотенца или скребок.

# Шаг 2: Наполнение раковины
# Наполнение раковины водой: Наполните раковину теплой водой и добавьте моющее средство для посуды.
# Замачивание посуды: Погрузите посуду в воду для размягчения остатков пищи и жира.

# Шаг 3: Мытье посуды
# Мытье тарелок и чашек: Начните с мытья тарелок и чашек, используя губку или щетку. Тщательно промойте каждую вещь.
# Мытье столовых приборов: Перейдите к мытью столовых приборов. Особое внимание уделите зубцам вилок и режущим кромкам ножей.
# Мытье кастрюль и сковородок: В последнюю очередь вымойте кастрюли и сковородки, так как они обычно самые грязные.

# Шаг 4: Полоскание
# Полоскание посуды: Промойте каждую вещь под проточной водой, чтобы удалить остатки моющего средства.

# Шаг 5: Сушка
# Сушка посуды: Поставьте чистую посуду на сушилку или протрите ее чистым полотенцем.

# Шаг 6: Завершение
# Уборка рабочего места: Вылейте грязную воду из раковины и промойте ее. Уберите моющее средство и губки.
# Уборка посуды: Уберите высушенную посуду на свои места.






# Блок-схема алгоритма мытья посуды
# +-----------------------------+
# | 1. Сортировка посуды        |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 2. Удаление остатков пищи   |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 3. Наполнение раковины водой|
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 4. Замачивание посуды       |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 5. Мытье тарелок и чашек    |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 6. Мытье столовых приборов  |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 7. Мытье кастрюль и сковородок|
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 8. Полоскание посуды        |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 9. Сушка посуды             |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 10. Уборка рабочего места   |
# +-------------+---------------+
#               |
#               v
# +-------------+---------------+
# | 11. Уборка посуды           |
# +-------------+---------------+










## Модуль 1. Введение в Python
# (часть 2)








# Задание 1
# Пользователь вводит с клавиатуры три числа. Необхо-
# димо найти сумму чисел, произведение чисел. Результат
# вычислений вывести на экран.


#print("Введите три числа:")

#a = int(input())
#b = int(input())
#c = int(input())

#d = a + b + c

#print(a, "+", b, "+", c, "=", d)





# Задание 2
# Пользователь вводит с клавиатуры три числа. Первое
# число — зарплата за месяц, второе число — сумма месяч-
# ного платежа по кредиту в банке, третье число — задол-
# женность за коммунальные услуги. Необходимо вывести
# на экран сумму, которая останется у пользователя после
# всех выплат.




#print() 

# x = int(input('введите зарплата за месяц'))   
# y = int(input('введидь сумма месячного платежа по кредиту в банке'))    
# z = int(input('введидь задолженность за коммунальные услуги.'))

#summa_plat= x - y - z 

#print(x, "-", y, "-",  z,"=" , summa_plat)





# Задание 3
# Напишите программу, вычисляющую площадь ром-
# ба. Пользователь с клавиатуры вводит длину двух его
# диагоналей.





# print("Найдите S")

# d1 = int(input("видите число"))
# d2 = int(input("видите другое число"))

# s = (d1+d2)/2 

# print('(',d1, "+", d2, ")/2=", s)





#Задание 4
# Выведите на экран надпись To be or not to be на разных
# строках. Пример вывода:
# To be
# or not
# to be





# print("To be")
# print("or not")
# print("to be")




# Задание 5
# Выведите на экран надпись «Life is what happens when
# you're busy making other plans» John Lennon на разных
# строках. Пример вывода:
# “Life is what happens
# when
# you’re busy making other plans”
# John Lennon.



# print("'Life is what happens \n    when\n       you’are busy making other plans\n                                  John Lennon.\n")






# Модуль 1 Введение в Python
# Часть 3




# Задание 1
# Пользователь вводит с клавиатуры три цифры. Необ-
# ходимо создать число, содержащее эти цифры. Например,
# если с клавиатуры введено 1, 5, 7, тогда нужно сформи-
# ровать число 157







# a = int(input("Введите число №1"))

# v = int(input(("Введите число №2")))

# n = int(input(("Введите число №3")))

# print(a,v,n)


# a = int(input("Введите число №1"))

# b = int(input("Введите число №2"))

# c = int(input("Введите число №3"))

# print(a*100+b*10+c)







# Задание 2
# Пользователь вводит с клавиатуры число, состоящее
# из четырех цифр. Требуется найти произведение цифр.
# Например, если с клавиатуры введено 1324, тогда резуль-
# тат произведения 1*3*2*4 = 24




# a = int(input("Введите число №1"))

# b = int(input("Введите число №2"))

# c = int(input("Введите число №3"))

# g = int(input("Введите число №4"))


# s = (a * b * c * g) 

# print("Площадь параллелепида равна" ,a, "*",b, "*",c,"*",g,"=",s)







# Задание 3
# Пользователь вводит с клавиатуры количество метров.
# Требуется вычислить количество сантиметров, а также количество миллиметров.
# тры, дециметры, миллиметры, мили.






# a = float(input("Введите количество метров"))

# s = (a * 100)
# print ("Сумма сантиметров в метрах  равна ", s, "сантиметров")

# a = float(input("Введите количество метров"))

# s = (a * 10)
# print ("Сумма сантиметров в метрах  равна ", s, "дацеметров")

# a = float(input("Введите количество метров"))

# s = (a * 1000)
# print ("Сумма сантиметров в метрах  равна ", s, "милимтров")

# a = float(input("Введите количество метров"))

# s = (a *  0.000621)
# print ("Сумма сантиметров в метрах  равна ", s, "миль")







# Задание 4
# Напишите программу, вычисляющую площадь тре-
# угольника. Пользователь с клавиатуры вводит размер
# основания треугольника и размер высоты.





# a = int(input("размер основания треугольника"))

# h = int(input("размер высоты треугольника"))

# summa_plat= S = (a*h)/2

# print("Площадь  треугольника равен ", S)

# print(a,"*"  , h, "/2 = ", S )






# Задание 5
# Пользователь с клавиатуры вводит четырёхзначное
# число. Необходимо перевернуть число и отобразить
# результат. Например, если введено 4512, результат 2154





# (запарестый способ)

# a = int(input("Введите число №1"))

# b = int(input("Введите число №2"))

# c = int(input("Введите число №3"))

# g = int(input("Введите число №4"))

# v = print(a*1000+b*100+c*10+g)

# v = input("Повторите результат если хотите перевернуть число")

# v = v[::-1]

# print(v)


# (легкий способ)

# number = input()
# number = number[::-1]
# print(number)






#Модуль 2 Операторы ветвлений
# Часть 1




# Задание 1
# Пользователь вводит с клавиатуры три числа. В за-
# висимости от выбора пользователя программа выводит
# на экран сумму трёх чисел или произведение трёх чисел.





# a = int(input("Введите число №1"))

# b = int(input("Введите число №2"))

# c = int(input("Введите число №3"))

# operation = input("Выберете один из вариантов решения - (+,*):")

# if operation == "+":
#     print(a + b + c)

# elif operation == "*":
#     print(a * b * c)
# else:
#     print("Вы ввели неверный оператор")



# Почему так нельзя делать?
# y = print(a * b * c) 
  
# y = print("сумма трех чисел равна")


# if print ==  2:  

# a = int(input("Введите число №1"))

# b = int(input("Введите число №2"))

# c = int(input("Введите число №3"))

# y=summa_plat= S = a * b * c 
# y=print("сумма трех чисел равна")
# y=print(S)





# Задание 2
# Пользователь вводит с клавиатуры три числа. В за-
# висимости от выбора пользователя программа выводит
# на экран максимум из трёх, минимум из трёх или сред-
# неарифметическое трёх чисел.



# a = int(input("Введите число №1"))

# b = int(input("Введите число №2"))

# c = int(input("Введите число №3"))

# all = [a, b, c]

# operation = input("Выберете один из вариантов решения чтобы найти последовательность - (a,b,c):")

# if operation == "a":
#       print ('Максимум из 3:', max(all))
# elif operation == "b":
#     print ('Минимум из 3:', min(all))
# elif operation == "c":
#      print('Среднее из 3:', sum(all) / len(all))
# else:
#     print("Вы ввели неверный вариант")




# Задание 3
# Пользователь вводит с клавиатуры количество ме-
# тров. В зависимости от выбора пользователя программа
# переводит метры в мили, дюймы или ярды.



# a = int(input("Введите количество метров"))

# operation = input("Выберете один из вариантов решения - (мили,дюймы,ярды): ")

# if operation == "мили":
#     print ('Мили:', a * 0.000621371192)

# if operation == "дюймы":
#     print ('Дюймы:', a * 39.3700787)

# if operation == "ярды":
#     print ('Ярды', a * 0.9144)
# else:
#     print("Вы ввели неверный вариант")






# Модуль 2 Операторы ветвлений
# Часть 2



#Задание 1
# Пользователь вводит с клавиатуры номер дня недели
# (1-7). Необходимо вывести на экран названия дня неде-
# ли. Например, если 1, то на экране надпись понедельник,
# а если 7, то на экране надпись воскресенье.




# operation = input("Введите номер недели (1,2,3,4,5,6,7): ")
# if operation == "1":
#     print("Понедельник")
# if operation == "2":
#     print("Ввторник")
# if operation == "3":
#     print("Среда")
# if operation == "4":
#     print("Четверг")
# if operation == "5":
#     print("Пятница")
# if operation == "6":
#     print("Суббота")
# if operation == "7":
#     print("Восскресенье")
# else:
#     print("Вы ввели неверный вариант")







# Задание 2
# Пользователь вводит с клавиатуры номер месяца
# (1-12). Необходимо вывести на экран название месяца.
# Например, если 1, то на экране надпись январь, 2 — фев-
# раль и т.д.






# num = int(input("Введите номер месяца (1,2,3,4,5,6,7,8,9,10,11,12): "))
# month = ['Январь','Февраль'///]
# print(month[num-1])
# if operation == "1":
#     print("Январь")
# if operation == "2":
#     print("Февраль")
# if operation == "3":
#     print("Март")
# if operation == "4":
#     print("Апрель")
# if operation == "5":
#     print("Май")
# if operation == "6":
#     print("Июнь")
# if operation == "7":
#     print("Июль")
# if operation == "8":
#     print("Август")
# if operation == "9":
#     print("Сентябрь")   
# if operation == "10":
#     print("Октябрь")
# if operation == "11":
#     print("Ноябрь")
# if operation == "12":
#     print("Декабрь")







# Задание 3
# Пользователь вводит с клавиатуры число. Если число
# больше нуля нужно вывести надпись «Number is positive»,
# если меньше нуля «Number is negative», если равно нулю
# «Number is equal to zero»






# peration = input("Введите число")

# peration = int(peration)

# if peration < 0:
#     print("«Number is negative»,")
# if peration > 0:
#     print("«Number is positive»,")
# if peration  == 0:
#     print("«Number is equal to zero»")






#Задание 4
# Пользователь вводит два числа. Определить, равны
# ли эти числа, и, если нет, вывести их на экран в порядке
# возрастания.






# a = input("Введите число №1 :")

# p = input("Введите число №2 :")


# if a == p: print('Эти два числа равны')

# elif a != p: print('Эти два числа не равны')

# if a > p: print('Первое число больше второго')

# if a < p: print('Второе число больше первого')








#Модуль 2 Операторы ветвления 
# Часть 3






#Задание 1
# Пользователь вводит с клавиатуры число в диапа-
# зоне от 1 до 100 Если число кратно 3 (делится на 3 без
# остатка) нужно вывести слово Fizz. Если число кратно 5
# нужно вывести слово Buzz. Если число кратно 3 и 5 нужно
# вывести Fizz Buzz. Если число не кратно не 3 и 5 нужно
# вывести само число.
# Если пользователь ввел значение не в диапазоне от 1
# до 100 требуется вывести сообщение об ошибке.





# a = int(input("Введите число от 1-100"))

# if  1 <=  a <= 100: 
#     print("Число входит в диапазон от 1 до 100:")
    
# # if a != 1 or a != 100:
# #         print("Ошибка")

# elif not a %3 == 0 :
#     print("Fizz")

# elif not a % 5 == 0:
#     print("Buzz")

# if not a % 3 == 0 and not a % 5 == 0:
#     print("Fizz Buzz")
# else:
#     print(a)
# else :
#  print("Ошибка,введите число в диапазоне [1; 100]")
# почему сдесь не поучаеться вести вторую если..?






#Задание 2
# Написать программу, которая по выбору пользова-
# теля возводит введенное им число в степень от нулевой
# до седьмой включительно.





# b = int(input("Введите число от 1-100"))

# a = int(input("Введите в каую степень вы хотите возвести число[0-7]:"))

# if 0 <= a <= 7:
  
#   print(a ** b)

# else:

#     print("Ошибка,введите число в диапазоне [0; 7]")





#Задание 3
# Написать программу подсчета стоимости разговора
# для разных мобильных операторов. Пользователь вводит
# стоимость разговора и выбирает с какого на какой опе-
# ратор он звонит. Вывести стоимость на экран.



# a = int(input("Введите стоимость разговора:"))
# b = int(input("Выбирите одного из опреторов [1-2-3-4]:"))

# if b == 1:
#     print(a * 0.95)
#     print("стоимость тарифа в руб")
# if b == 2:
#     print(a * 0.92)
#     print("стоимость тарифа в руб")
# if b == 3:
#     print(a * 0.9) 
#     print("стоимость тарифа в руб")
# if b == 4:
#     print(a * 0.85) 
#     print("стоимость тарифа в руб")






# Задание 4
# Зарплата менеджера составляет 200$ + процент от про-
# даж, продажи до 500$ — 3%, от 500 до 1000 — 5%, свыше
# 1000 — 8%. Пользователь вводит с клавиатуры уровень
# продаж для трех менеджеров. Определить их зарплату,
# определить лучшего менеджера, начислить ему премию
# 200$, вывести итоги на экран.




# r = int(input("Введите сумму продаж для 1 менеджера [ОТ 500-1000]:"))
# a = int(input("Введите уровень продаж  для 1 менеджера[ОТ 3-8%]:"))

# if print(r/100*a):
#     print("1 менеджер")


# n = int(input("Введите сумму продаж для 2 менеджера [ОТ 500-1000]:"))
# b = int(input("Введите уровень продаж  для 2 менеджера[ОТ 3-8%]:"))

# if print(n/100*b):
#  print("2 менеджер")


# m = int(input("Введите сумму продаж для 3 менеджера [ОТ 500-1000]:"))
# c = int(input("Введите уровень продаж  для 3 менеджера[ОТ 3-8%]:"))


# if  print(m/100*c):
#  print("3 менеджер")



# g = int(input("Какой мененджр лучше всех сделал свою работу?: "))

# if not g == 1:
#     print(r/100*a  + 200)
#     print("1 менеджер получает прибавку 200$")

# elif not g == 2:
#     print(n/100*b + 200)
#     print("2 менеджер получает прибавку 200$")

# elif not  g == 3:
#     print(r/100*a + 200)
#     print("3 менеджер получает прибавку 200$")

# else:
#     print("Такого менеджера нет")






#Модуль 3 Цикл: 
# Часть 1









# Задание 1
# Пользователь вводит с клавиатуры два числа (нача-
# ло и конец диапазона). Требуется проанализировать все
# числа в этом диапазоне по следующему правилу: если
# число кратно 7, его надо выводить на экран.







# a = int(input("Ведите число номер 1(начало):"))

# b = int(input("Ведите число номер 2(конец):"))


# for i in range(a, b):
#     print(i)
#     if i == a:
#         print("Начало")
# if i == b:
#         print("Конец")
#         for i in range(a,b+1): 
#  (i%7==0):
#  print(i)
# else a == b:
#         raise RuntimeError
# print('Числа не могут быть одинаковыми')

# a = int(input("Ведите число номер 1(начало):"))
# b = int(input("Ведите число номер 2(конец):"))

# for i in range(a, b +1):
#     print(i)
#     if i == a:
#         print("Начало")
#     if i == b:
#         print("Конец")
#     if i % 7 == 0:
#         print(f"Найдена кратная 7: {i}")







# Задание 2
# Пользователь вводит с клавиатуры два числа (нача-
# # ло и конец диапазона). Требуется проанализировать все
# числа в этом диапазоне. Нужно вывести на экран:
# 1 Все числа диапазона;
# 2 Все числа диапазона в убывающем порядке;
# 3 Все числа, кратные 7;
# 4 Количество чисел, кратных 5






# a = int(input("Ведите число номер 1(начало): "))
# b = int(input("Ведите число номер 2(конец): "))

# for i in range(a-1, b-1,-1 ):
#     print(i)
#     if i == a:
#         print("начало:")
#     if i == b:
#         print("конец:")
        
#     if i % 7 == 0:
#         print(f" Найдена кратная 7: {i}")
#     if i % 5 == 0:
#         print(f"Найдена кратная 5: {i}")








# Задание 3
# Пользователь вводит с клавиатуры два числа (начало
# # и конец диапазона). Требуется проанализировать все
# в этом диапазоне. Вывод на экран должен проходить по
# правилам, указанным ниже.
# Если число кратно 3 (делится на 3 без остатка) нужно
# вывести слово Fizz. Если число кратно 5 нужно выве-
# сти слово Buzz. Если число кратно 3 и 5 нужно вывести
# Fizz Buzz. Если число не кратно не 3 и 5 нужно вывести
# само число.






# a = int(input("Ведите число номер 1(начало):"))
# b = int(input("Ведите число номер 2(конец):"))

# for i in range(a, b +1):
#     print(i)
#     if i == a:
#         print("Начало")
#     if i == b:
#         print("Конец")
#     if i % 3 == 0:
#         print(f"Fizz: {i}")
#     if i % 5 == 0:
#         print(f"Buzz: {i}")
#     if i % 3 and 5 == 0:
#         print(f"Fizz Buzz: {i}")
#     if not i % 3 and 5 == 0:
#         print(f"Cамо число{i}")


# a = int(input("Ведите число номер 1(начало):"))
# b = int(input("Ведите число номер 2(конец):"))

# for i in range(a, b +1):
#     print(i)
#     if i == a:
#         print("Начало")
#     if i == b:
#         print("Конец")
#     if i % 3 == 0:
#         print(f"Fizz: {i}")
#     if i % 5 == 0:
#         print(f"Buzz: {i}")
#     if i % 3 == 0 and i % 5 == 0:
#         print(f"Fizz Buzz: {i}")
#     if not i % 3 and not i % 5:
#         print(f" не делиться не на 3 не на 5{i}")









#Модуль 3 Цикл: 
# Часть 2







# Задание 1
# Пользователь вводит с клавиатуры два числа. Нужно
# посчитать отдельно сумму четных, нечетных и чисел,
# кратных 9 в указанном диапазоне, а также среднеариф-
# метическое каждой группы.






# a = int(input("Ведите число номер 1(начало):"))
# b = int(input("Ведите число номер 2(конец):"))

# sred_arvmet = 0
# nine_sum = 0

# for i in range(a, b +1):

#     print(i)
#     if i == a:

#         print("Начало")
#     if i == b:

#         print("Конец")
#     if i % 9 == 0:

#         print(f"кратно:{i}")

#     if i % 2 == 0:
#      nine_sum = 0
#      sred_arvmet += 1
#      print(f"четное: {i}")   

#     else: not i % 2 == 0
#     nine_sum  += i
#     sred_arvmet += 1
#     print(f"нечётное: {i}")    

#     print(f"Среднеарифметическое нечетных чисел:{sred_arvmet/nine_sum }")





# Задание 2
# Пользователь вводит с клавиатуры длину линии и
# символ для заполнения линии. Нужно отобразить на
# экране вертикальную линию из введенного символа,
# указанной длины.
# Например, если было введено 5 и символ %, тогда
# вывод на экран будет такой:
# %
# %
# %
# %
# %





# length = int(input("Введите длину линии: "))
# symbol = input("Введите символ для заполнения линии: ")

# for i in range(length):
#     print(symbol)





# Задание 3
# Пользователь вводит с клавиатуры числа. Если число
# больше нуля нужно вывести надпись «Number is positive»,
# если меньше нуля «Number is negative», если равно нулю
# «Number is equal to zero». Когда пользователь вводит
# число 7 программа прекращает свою работу и вывводит
# на экран надпись «Good bye!»


# a = int(input("Ведите число больше [0]:"))
# if a < 0 :
#     print("«Number is positive»")
# if 0 > a: 
#     print("«Number is negative»")
# else:
#     print("Number is equal to zero")

# if a == 7:
#     print("Good bye!")
        



# Задание 4
# Пользователь вводит с клавиатуры числа. Програм-
# ма должна подсчитывать сумму, максимум и минимум,
# введенных чисел. Когда пользователь вводит число 7
# программа прекращает свою работу и выводит на экран
# надпись «Good bye!»




# a = int(input("Ведите число 1:"))
# b = int(input("Ведите число 2:"))
# c = int(input("Ведите число 3:"))
# 19

# if a > b and a > c:
#  print("Макимально число[A]:", a)

# elif b > a and b > c:
#  print("Макимально число[B]:", b)


# elif c > a and c > b:
#  print("Макимально число[С]:", c)






#Модуль 3 Циклы.
# Часть 3




# Задание 1
# Напишите программу, которая запрашивает два
# целых числа x и y, после чего вычисляет и выводит
# значение x в степени y.


# x = int(input("Ведите чётное число [1]:"))

# y = int(input("Ведите чётное число [2]:"))

# результат = pow(x,y)

# print(результат)








# Задание 2
# Подсчитать количество целых чисел в диапазоне от
# 100 до 999 у которых есть две одинаковые цифры.






# count = 0 
# for i in range(100, 1000): 
#     num = str(i) 
#     if num[0] == num[1] or num[0] == num[2] or num[1] == num[2]: 
#         count += 1 
# print(count)








# Задание 3
# Подсчитать количество целых чисел в диапазоне от
# 100 до 9999 у которых все цифры разные.








# count = 0
# for i in range(100, 10000):
#     num = str(i)
#     if num[0] != num[1] and num[0] != num[2] and num[0] != num[
#         3] and num[1] != num[2] and num[1] != num[3] and num[2]
#         != num[3]:
#         count += 1
# print(count)







# Задание 4
# Пользователь вводит любое целое число. Необхо-
# димо из этого целого числа удалить все цифры 3 и 6 и
# вывести обратно на экран.






# a = int(input("Ведите любое целое число:"))

# ???????









# Модуль 3 Циклы.
# Часть 4








# Задание 1
# Показать на экран все простые числа в диапазоне,
# указанном пользователем. Число называется простым,
# если оно делится без остатка только на себя и на единицу.
# Например, три — это простое число, а четыре нет.






# a = int(input("Ведите число которое будет являться начлом диапозонна: "))

# b = int(input("Ведите число которое будет являться концом диапозонна: "))

# for i in range(a,b +1):

#     is_prime = True
    

#     for j in range(2, i):

#         if i % j == 0:

#             is_prime = False
           
#             break

#     if is_prime:

#         print(f"{i}-простое число:")







# Задание 2
# Показать на экране таблицу умножения для всех чисел
# от 1 до 10 Например:

# 1 * 1 = 1 1 * 2 = 2 ….. 1 * 10 = 10
# .........................................................................
# 10 * 1 = 10 10 * 2 = 20 …. 10 * 10 = 100

# for x in range(1,11):

#  for y in range(1,11):
#   print(f"{x} * {y} = {x*y}")
#   print()






# Задание 3
# Показать на экран таблицу умножения в диапазоне,
# указанном пользователем. Например, если пользователь
# указал 3 и 5, таблица может выглядеть так

# 3*1 = 3 3*2 = 6 3*3 = 9 ... 3 * 10 = 30
# .....................................................................................
# 5*1 = 5 5 *2 = 10 5 *3 = 15 ... 5 * 10 = 50







# a = int(input("Ведите число которое будет являться начлом диапозонна: "))
# b = int(input("Ведите число которое будет являться концом диапозонна: "))
# for x in range(a,b +1):
#     for y in range(1,11):
#         print(f"{x} * {y} = {x*y}")






# Модуль 3 Циклы.
# Часть 5





# Задание
# Вывести на экран фигуры, заполненные звездочками.
# Диалог с пользователем реализовать при помощи меню.






# while True:
#     variant = input('Введите вариант от "а" до "к"')
#     length = int(input('Ведите нечётно число'))
#     string = ''
#     for y in range(length):
#         for x in range(length):
#             match variant:
#                 case 'а':
#                     if y <= x:
#                         string += "*"
#                     else:
#                         string += " "
#                 case 'б':
#                     if y >= x:
#                         string += "*"
#                     else:
#                         string += " "
#                 case 'в':
#                     if y == x:
#                         string += "*"
#                     else:
#                         string += " "
#                 case 'г':
#                     if y + x == length - 1:
#                         string += "*"
#                     else:
#                         string += " "
#                 case 'д':
#                     if y == length - 1 - x:
#                         string += "*"
#                     else:
#                         string += " "
#                 case 'е':
#                     if y == x or y == length - 1 - x:
#                         string += "*"
#                     else:
#                         string += " "
#                 case 'ж':
#                     if y == x or y == length - 1 - x or y + x == length - 1:
#                         string += "*"
#                     else:
#                         string += " "
#                 case 'з':
#                     if y == x or y == length - 1 - x or y + x == length - 1 or y + x == length - 1 - x:
#                         string += "*"
#                     else:
#                         string += " "
#                 case 'и':
#                     if y == x or y == length - 1 - x or y + x == length - 1 or y + x == length - 1 - x or y == length - 1 - x or y + x == length - 1 - x:
#                         string += "*"
#                     else:
#                         string += " "
#                 case 'к':
#                     if y == x or y == length - 1 - x or y + x == length - 1 or y + x == length - 1 - x or y == length - 1 - x or y + x == length - 1 - x or y + x == length - 1 or y + x == length:
#                         string += "*"
#                     else:
#                         string += " "
#                 case _:
#                     pass
#             string += "\n"
#         print(string)








# Модуль 4 Строки. Списки.
# Часть 1







# Задание 1
# Пользователь вводит с клавиатуры строку. Проверьте
# является ли введенная строка палиндромом. Палин-
# дром - слово или текст,которое читаеться одинаково
# слева направо и справа налево. Например, кок; А роза
# упала на лапу Азора; доход; А буду я у дуба.








# def palindrom():

#     string = input("Введите строку: ")

#     string = string.lower()

#     string = string.replace(" ", "")

#     if string == string[::-1]: ## Проверяет, является ли строка такой же, если изменить ее местами,если не находит слово которое не меняеться  то  выводит принт.

#         print("Строка является палиндромом")

#     else:

#         print("Строка не является палиндромом")

# palindrom()








# Задание 2
# Пользователь вводит с клавиатуры некоторый текст,
# после чего пользователь вводит список зарезервированных
# слов. Необходимо найти в тексте все зарезервированные
# слова и изменить их регистр на верхний. Вывести на
# # экран измененный текст.






# def palindrom():

#     string = input("Введите строку: ")

    # string = string.lower() ##Получаем вводимые пользователем данные и преобразуем их в нижний регистр

#     string = string.replace(" ", "") ## Убираем пробелы из строки

#     string = string.split()

#     print(string)

#     for i in string:

#         if i in string: ## Проверить, не появляется ли какой-либо символ в строке более одного разадля i в строке:

#             print(i.upper())


# palindrom()






# Задание 3
# Есть некоторый текст. Посчитайте в этом тексте ко-
# личество предложений и выведите на экран полученный
# результат.




# def palindrom():

# string = input("Введите строку: ")

# string = string.lower()##-Метод - lower() ##используется для преобразования строки в нижний регистр.

# string = string.replace(" ", "")##-Метод - replace() ##используется для удаления пробелов из строки.

# string = string.split(".")##-Метод split() ##используется для разделения строки на список подстрок с использованием символа "." в качестве разделителя.

# print(string)##-Функция - print() ##используется для печати списка подстрок и его длины.

# print(len(string))##-Функция - len()## используется для получения длины списка подстрок.






# Модуль 4 Строки. Списки.
# Часть 2






# Задание 1:
# Пользователь вводит с клавиатуры арифметическое
# выражение. Например, 23+12.
# Необходимо вывести на экран результат выражения.
# В нашем примере это 35 Арифметическое выражение
# может состоять только из трёх частей: число, операция,
# число. Возможные операции: +, -,*,/







# def palindrom():

#     string = input("Введите арифметическое выражение: ") ##Предлагает пользователю ввести арифметическое выражение, например "2 + 3" или "4 * 5".

#     string = string.split() ##string = строка.split(): Разбивает входную строку на список слов, используя пробел в качестве разделителя. Например, "2 + 3" станет ["2", "+", "3"].

#     print(string) ##выводит список слов на консоль.

#     print(string[0]+string[2]) ##выводит объединение первого и третьего элементов списка. В приведенном выше примере это означало бы вывод "23".

# palindrom()







# Задание 2:
# В списке целых, заполненном случайными числами,
# определить минимальный и максимальный элементы,
# посчитать количество отрицательных элементов, посчи-
# тать количество положительных элементов, посчитать
# количество нулей. Результаты вывести на экран.






# import random

# def palindrom():

#     list = [random.randint(-100, 100) for i in range(21)] ##

#     print(list)

#     print(max(list)) ##выводит максимальный элемент списка.

#     print(min(list)) ##выводит минимальный элемент списка.

#     print(list.count(0)) ##выводит количество нулей в списке.
    
#     countOtr = 0
#     for n in list:
#         if n < 0:
#             countOtr += 1
#     print(countOtr) ##выводит количество отрицательных элементов в списке
    
#     countPol = 0
#     for n in list:
#         if n > 0:
#             countPol += 1
#     print(countPol) ##выводит количество положительных элементов в списке

# palindrom()







# Модуль 4 Строки. Списки.
# Часть 3




# Задание 1
# Два списка целых заполняются случайными числами.
# Необходимо:
# ■ Сформировать третий список, содержащий элементы
# обоих списков;
# ■ Сформировать третий список, содержащий элементы
# обоих списков без повторений;
# ■ Сформировать третий список, содержащий элементы
# общие для двух списков;
# ■ Сформировать третий список, содержащий только
# уникальные элементы каждого из списков;
# ■ Сформировать третий список, содержащий только
# минимальное и максимальное значение каждого из
# списков. 





## Два списка целых заполняются случайными числами.
## Необходимо:

# import random
# def task1():
#      print
# list1 = [random.randint(-100, 100) for _ in range(10)]

# list2 = [random.randint(-100, 100) for _ in range(10)]

# print("List 1:", list1)
# print("List 2:", list2)

# # Сформировать третий список, содержащий элементы
# # обоих списков;

# list3 = list1 + list2
# print("List 3:", list3)

# # формировать третий список, содержащий элементы
# # обоих списков без повторений;

# list4 = list(set(list1 + list2))
# print("List 4:", list4)

# # Сформировать третий список, содержащий элементы
# # общие для двух списков;

# list5 = list(set(list1) & set(list2))
# print("List 5:", list5)

# # Сформировать третий список, содержащий только
# # уникальные элементы каждого из списков;

# list6 = list(set(list1) ^ set(list2))
# print("List 6:", list6)
 
# # минимальное и максимальное значение каждого из
# # списков

# list7 = [min(list1), max(list1), min(list2), max(list2)]
# print("List 7:", list7)
# task1()







# Модуль 5 Функции. Функции.
# Часть 1








# Задание 1
## Напишите функцию, которая отображает на экран
## форматированный текст, указанный ниже:
## “Don't compare yourself with anyone in this world…
## if you do so, you are insulting yourself.”
##                                           Bill Gates






# print("“Don't compare yourself with anyone in this world…")
# print ("if you do so, you are insulting yourself.”")
# print("                                           Bill Gates")






# Задание 2
## Напишите функцию, которая принимает два числа
## в качестве параметра и отображает все четные числа
## между ними






# def print_even_numbers(a, b):
#     for i in range(a, b+1):
#         if i % 2 == 0:
#             print(i)
# print_even_numbers(1, 10)








# Задание 3
## Напишите функцию, которая отображает пустой или
## заполненный квадрат из некоторого символа. Функция
## принимает в качестве параметров: длину стороны ква-
## драта, символ и переменную логического типа
## если она равна True, квадрат заполненный
## если False, квадрат пустой







## (True или False), указывающую, является ли квадрат
##  пустым или заполненным

# def print_square(size, symbol, is_empty):
#     if is_empty:
#         for i in range(size):
#             if i == 0 or i == size - 1:
#                 print(symbol * size)
#             else:
#                 print(symbol + " " * (size - 2) + symbol)
#     else:
#         for i in range(size):
#             print(symbol * size)
# print_square(5, '*', True)







## Задание 4
## Напишите функцию, которая возвращает минимальное
## из пяти чисел Числа передаются в качестве параметров









# import random 
# import math

# def min_of_five(a, b, c, d, e):
#     return min(a, b, c, d, e)

# print(min_of_five(1, 2, 3, 4, 5))

# print(min_of_five(random.randint(1,5), random.randint(1,5)
                  
# , random.randint(1,5), random.randint(1,5), random.randint
# (1,5)))

# print(min_of_five(math.pi, math.e, math.sqrt(2), math.sqrt(3)
# , math.sqrt(5)))



## Этот код определяет функцию min_of_five, которая принимает пять аргументов и возвращает минимальное значение из них. Затем функция вызывается три раза с разными наборами аргументов:

## С числами 1, 2, 3, 4 и 5.
## С пятью случайными целыми числами от 1 до 5.
## С пятью математическими константами: π, e, √2, √3 и √5.
## Вот краткое описание того, как работает код:

## Первый вызов:


## Печать кода копирования(min_of_five(1, 2, 3, 4, 5))
## Функция min_of_five вызывается с аргументами 1, 2, 3, 4 и 5. Функция min возвращает наименьшее значение из этих аргументов, равное 1. Результатом будет 1.

## Второй вызов:


## Печать кода копирования(min_of_five(random.randint(1,5), random.randint(1,5),
## random.randint(1,5), random.randint(1,5), random.randint(1,5)))
## Функция min_of_five вызывается с пятью случайными целыми числами от 1 до 5. Функция random.randint генерирует случайное целое число от 1 до 5 для каждого аргумента. Функция min возвращает наименьшее значение из этих случайных целых чисел


# import random
# import math

# def min_of_five(args):
#     return min(args)

# print(min_of_five([1, 2, 3, 4, 5]))

# print(min_of_five([random.randint(1,5) for _ in range(5)]))

# print(min_of_five([math.pi, math.e, math.sqrt(2), math.sqrt(3), math.sqrt(5)]))







## Задание 5
## Напишите функцию, которая возвращает произве-
## дение чисел в указанном диапазоне. Границы диапазона
## передаются в качестве параметров. Если границы диапа-
## зона перепутаны (наппример, 5- верхняя граница,25-)
## нижняя граница), их нужно поменять местами






# import math
# def product_of_range(a, b):
#     if a > b:
#         a, b = b, a
#     product = 1
#     for i in range(a, b + 1):
#         product *= i
#     return product
# print(product_of_range(5, 25))
# print(product_of_range(25, 5))






## Задание 6
## Напишите функцию, которая считает количество
## цифр в числе. Число передаётся в качестве параметра. Из
## функции нужно вернуть полученное количество цифр.
## Например, если передали 3456, количество цифр будет 4






# def count_digits(n):
#     return len(str(abs(n)))
# print(count_digits(3456))
# print(count_digits(-3456))







## Задание 7
## Напишите функцию, которая проверяет является ли
## число палиндромом. Число передаётся в качестве пара-
## метра. Если число палиндром нужно вернуть из функции
## true, иначе false.
## «Палиндром» — это число, у которого первая часть
## цифр равна второй перевернутой части цифр. Например,
## 123321 — палиндром (первая часть 123, вторая 321, которая
## после переворота становится 123), 546645 — палиндром,
## а 421987 — не палиндром.





# def is_palindrome(n):
#     return str(n) == str(n)[::-1]
# print(is_palindrome(123321)) # True
# print(is_palindrome(546645)) # True
# print(is_palindrome(421987)) # False





## Модуль 5 Функции. Функции.(Часть 2)







## Задание 1
## Напишите функцию, вычисляющую произведение
## элементов списка целых. Список передаётся в качестве па-
## раметра. Полученный результат возвращается из функции







# def product_of_list(lst):

#     product = 1

#     for i in lst:

#         product *= i

#     return product

# print(product_of_list([1, 2, 3, 4, 5]))


## 1. def product_of_list(lst):: Эта строка определяет функцию с именем product_of_list, которая принимает единственный аргумент lst, представляющий собой список чисел.

## 2. product = 1: В этой строке переменная product инициализируется значением 1. Эта переменная будет использоваться для хранения результатов всех элементов в списке.

## 3. for i в lst:: Эта строка запускает цикл for, который будет выполнять итерацию по каждому элементу i в списке lst.

## 4. product *= i: Внутри цикла эта строка умножает текущее значение product на текущий элемент i. Это делается с помощью оператора *=, который является сокращением от product = продукт * i.

## 5. возвращает product: После того, как цикл завершает итерацию по всем элементам в списке, эта строка возвращает конечное значение product, которое является произведением всех элементов в списке.



## Теперь давайте посмотрим, как эта функция работает с примером входных данных [1, 2, 3, 4, 5]:

## Итерация 1: product = 1 i = 1 product *= 1 => product = 1

## Итерация 2: product = 1 i = 2 product *= 2 => продукт = 2







## Задание 2
## Напишите функцию для нахождения минимума в
## списке целых. Список передаётся в качестве параметра.
## Полученный результат возвращается из функции






# def find_min(lst):

#     return min(lst)

# numbers = [4, 2, 9, 1, 7, 3]

# min_value = find_min(numbers)

# print(min_value)  # Output: 1







## Задание 3
## Напишите функцию, определяющую количество про-
## стых чисел в списке целых. Список передаётся в качестве
## параметра. Полученный результат возвращается из функции







# def count_even_numbers(lst):

#     count = 0

#     for num in lst:

#         if num % 2 == 0:

#             count += 1

#     return count

# numbers = [1, 2, 3, 4, 5, 6]

# even_count = count_even_numbers(numbers)

# print(even_count)  # Output: 3







## Задание 4
## Напишите функцию, удаляющую из списка целых
## некоторое заданное число. Из функции нужно вернуть
## количество удаленных элементов







# def remove_number(lst, num):

#     count = 0

#     for i in range(len(lst) - 1, -1, -1):

#         if lst[i] == num:

#             lst.pop(i)

#             count += 1

#             return count
        
#         return count
    
#     numbers = [1, 2, 2, 3, 2, 4,]

#     removed_count = remove_number(numbers, 2)

#     print(removed_count)  # Output: 3






## Задание 5
## Напишите функцию, которая получает два списка в
## качестве параметра и возвращает список, содержащий
## элементы обоих списков






# def merge_lists(list1, list2):

#     return list1 + list2

# list1 = [1, 2, 3]

# list2 = [4, 5, 6]

# print(merge_lists(list1, list2))  # Output: [1, 2,]







## Задание 6
## Напишите функцию, высчитывающую степень каждого
## элемента списка целых. Значение для степени передаётся
## в качестве параметра, список тоже передаётся в качестве
## параметра. Функция возвращает новый список, содержа-
## щий полученные результаты





# def merge_lists(lst):

#     return [i**2 for i in lst]

# def power_list(lst, power):
         
#          return [i**power for i in lst]

# list1 = [1, 2, 3, 4, 5]

# print(power_list(list1, 2))  # Output: [1, 4, 9]





## Модуль 5 Функции. Функции.(Часть 3)





## Задание 1
## Написать рекурсивную функцию нахождения наи-
## большего общего делителя двух целых чисел





# def gcd(a, b):

#     if b == 0:

#         return a
    
#     else:

#         return gcd(b, a % b) 
    
# print(gcd(12, 15))  # Output: 3











# Задание 2
# Написать игру «Быки и коровы». Программа «за-
# гадывает» четырёхзначное число и играющий должен
# угадать его. После ввода пользователем числа программа
# сообщает, сколько цифр числа угадано (быки) и сколько
# цифр угадано и стоит на нужном месте (коровы). После
# отгадывания числа на экран необходимо вывести коли-
# чество сделанных пользователем попыток. В программе
# необходимо использовать рекурсию







# import random

# def game():

#     number = str(random.randint(1000, 9999))  # загадываем число

#     attempts = 0

#     while True:

#         guess = input("Введите четырёхзначное число: ")

#         if len(guess) != 4 or not guess.isdigit():

#             print("Некорректный ввод. Введите четырёхзначное число")

#             continue

#         attempts += 1

#         bulls = 0

#         cows = 0

#         for i in range(4):

#             if guess[i] == number[i]:

#                 bulls += 1

#             elif guess[i] in number:
             
#              cows += 1

#             print(f"Быки: {bulls}, Коровы: {cows}")

#             if bulls == 4:
             
#              print(f"Вы угадали! Количество попыток: {attempts}")
#             break
        
# game() # запуск игры

        

## Вот пошаговое объяснение того, как работает код:

## 1. Импорт модуля random

## Код начинается с импорта модуля random, который используется для генерации случайного числа.

## 2. Определение функции game()

## Определена функция game(), которая будет содержать логику игры.

## 3. Генерация случайного числа

## Переменной number задается случайное четырехзначное число с помощью random.randint(1000, 9999). Это число будет секретным номером, который пользователь должен угадать.

## 4. Инициализация переменной attempts

## Переменной attempts присваивается значение 0, которое будет отслеживать количество попыток пользователя угадать число.

## 5. Вход в игровой цикл

## Код переходит в бесконечный цикл, используя while True:. Этот цикл будет продолжаться до тех пор, пока пользователь правильно не угадает число.

## 6. Получение пользовательского ввода

## Пользователю предлагается ввести четырехзначное число с помощью ввода("Введите значение: "). Введенные данные сохраняются в переменной guess.

## 7. Проверка правильности ввода пользователем

## Код чепроверьте правильность введенных пользователем данных, проверив, составляет ли длина введенных данных 4 символа и все ли символы являются цифрами, используя len(угадайте) != 4 или не угадывайте.isdigit(). Если вводимые данные неверны, выводится сообщение об ошибке, и цикл продолжается.

## 8. Увеличение переменной attempts

## Если вводимые данные верны, переменная attempts увеличивается на 1.

## 9. Инициализация переменных bulls и cows

## Переменным bulls и cows присваивается значение 0. Эти переменные будут использоваться для отслеживания количества правильных цифр в правильном положении (bulls) и количества правильных цифр в неправильном положении (cows).

## 10. Сравнение догадки с секретным номером

## Код повторяет каждую цифру предположения и сравнивает ее с соответствующей цифрой секретного номера, используя значение для i в диапазоне(4):. Если цифра совпадает в точности, это увеличивает значение переменной bulls. Если в секретном номере присутствует цифра, но она находится в неправильном положении, значение переменной cows увеличивается.

## 11. Вывод результата на печать

## Код выводит количество быков и коров с помощью print(f"Быки: {быки}, Коровы: {коровы}").

## 12. Проверяем, выиграл ли пользователь

## Если количество буллов равно 4, это означает, что пользователь правильно угадал число, и игра выиграна. Код выводит поздравительное сообщение с количеством попыток, сделанных с помощью print("Спасибо! Количество попыток: {attempts}").

## 13. Выход из цикла

## Если пользователь выиграл, код выходит из цикла с помощью break.

## 14. Запуск игры

## Наконец, для запуска игры вызывается функция game().








## Задание 4
## Написать игру «Пятнашки».









# def game():
    
#     import random

# # Заготовки для отображения поля
# up = """+-----+-----+-----+-----+
# |     |     |     |     |"""
# mid = """|     |     |     |     |
# +-----+-----+-----+-----+
# |     |     |     |     |"""
# bot = """|     |     |     |     |
# +-----+-----+-----+-----+"""

# def get_new_random():
#     line = list(range(16))
#     return line

# def print_board(new_game):
#     print(up)
#     for i in range(0, 16):
#         if new_game[i]<10:
#             if new_game[i] == 0:
#                 print('| ', end = '')
#             else:
#                 print('| '+str(new_game[i])+' ', end = '')
#         else:
#             num = str(new_game[i])
#             print('| '+num[0]+' '+num[1]+' ', end = '')
#         if i == 3 or i == 7 or i == 11:
#             print('|')
#             print(mid) 
#     print('|')
#     print(bot)

# def ansver():
#     while True:
#         text = input('Введите число от 1 до 15:')
#         if text.isdigit() == False:
#             print('Вводите только целые числа!')
#         elif 15<int(text) or int(text)<0:
#             print('Нет такого числа на игровом поле!')
#         else:
#             return int(text)

# def possible_moves(new_game):
#     moves = []
#     ind = new_game.index(0)
#     if ind == 0:
#         moves.append(new_game[1])
#         moves.append(new_game[4])
#     elif ind == 1:
#         moves.append(new_game[0])
#         moves.append(new_game[2])
#         moves.append(new_game[5])
#     elif ind == 2:
#         moves.append(new_game[1])
#         moves.append(new_game[3])
#         moves.append(new_game[6])
#     elif ind == 3:
#         moves.append(new_game[2])
#         moves.append(new_game[7])
#     elif ind == 4:
#         moves.append(new_game[0])
#         moves.append(new_game[5])
#         moves.append(new_game[8])
#     elif ind == 5:
#         moves.append(new_game[1])
#         moves.append(new_game[4])
#         moves.append(new_game[6])
#         moves.append(new_game[9])
#     elif ind == 6:
#         moves.append(new_game[2])
#         moves.append(new_game[5])
#         moves.append(new_game[7])
#         moves.append(new_game[10])
#     elif ind == 7:
#         moves.append(new_game[3])
#         moves.append(new_game[6])
#         moves.append(new_game[11])
#     elif ind == 8:
#         moves.append(new_game[4])
#         moves.append(new_game[9])
#         moves.append(new_game[12])
#     elif ind == 9:
#         moves.append(new_game[5])
#         moves.append(new_game[8])
#         moves.append(new_game[10])
#         moves.append(new_game[13])
#     elif ind == 10:
#         moves.append(new_game[6])
#         moves.append(new_game[9])
#         moves.append(new_game[11])
#         moves.append(new_game[14])
#     elif ind == 11:
#         moves.append(new_game[7])
#         moves.append(new_game[10])
#         moves.append(new_game[15])
#     elif ind == 12:
#         moves.append(new_game[8])
#         moves.append(new_game[13])
#     elif ind == 13:
#         moves.append(new_game[9])
#         moves.append(new_game[12])
#         moves.append(new_game[14])
#     elif ind == 14:
#         moves.append(new_game[10])
#         moves.append(new_game[13])
#         moves.append(new_game[15])
#     else:
#         moves.append(new_game[11])
#         moves.append(new_game[14])
#     return moves

# # Основной код игры
# win = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0]
# new_game = get_new_random()
# print_board(new_game)

# while True:
#     moves = possible_moves(new_game)
#     move_num = ansver()
#     if move_num in moves:
#         ind_move = new_game.index(move_num)
#         ind_0 = new_game.index(0)
#         new_game[ind_0] = move_num
#         new_game[ind_move] = 0
#         print_board(new_game)
#     else:
#         print('Это число нельзя переместить!')
#     if new_game == win:
#         print('Поздравляю! Вы победили!')
#         break







## Модуль 7 Сортировка и поиск. Сортировка и поиск(Часть 1)






## Задание 1
## Необходимо отсортировать первые две трети списка
## в порядке возрастания, если среднее арифметическое
## всех элементов больше нуля; иначе — лишь первую треть.
## Остальную часть списка не сортировать, а расположить
## в обратном порядке.







# def sort_list(lst):
#     n = len(lst)
#     avg = sum(lst) / n
#     if avg > 0:
#         lst[:2*n//3] = sorted(lst[:2*n//3])
#     else:
#         lst[:n//3] = sorted(lst[:n//3])
#         lst[n//3:] = lst[n//3:][::-1]
#     return lst

# lst = [1, 2, 3, 4, 5, 6]
# print(sort_list(lst)) # [1, 2, 3, 6,]
# print = 








## Задание 2
## Написать программу «успеваемость». Пользователь
## вводит 10 оценок студента. Оценки от 1 до 12 Реализовать
## меню для пользователя:
## ■ Вывод оценок (вывод содержимого списка);
## ■ Пересдача экзамена (пользователь вводит номер эле-
## мента списка и новую оценку);
## ■ Выходит ли стипендия (стипендия выходит, если
## средний бал не ниже 10.7);
## ■ Вывод отсортированного списка оценок: по возрас-
## танию или убыванию







# def sort_list(lst):

#     n = len(lst)

#     avg = sum(lst) / n

#     if avg > 10.7:

#         return True

#     else:

#       return false

# lst = [1, 2, 3, 4, 5, 6]
# print(sorted(lst))
# print(sorted(lst)[::-1])
# print(sort_list(lst)) # [1, 2, 3, 6,]








# Задание 3
## Написать программу, реализующую сортировку списка
## методом усовершенствованной сортировки пузырьковым
## методом. Усовершенствование состоит в том, чтобы ана-
## лизировать количество перестановок на каждом шагу, если
## это количество равно нулю, то продолжать сортировку
## нет смысла — список отсортирован







# lst = [1, 2, 3, 4, 5, 6]

# def sort_list(lst):

#     n = len(lst)

#     for i in range(n - 1):

#         count = 0

#         for j in range(n - i - 1):

#             if lst[j] > lst[j + 1]:

#                 lst[j], lst[j + 1] = lst[j + 1], lst[j]

#                 count += 1

#         if count == 0:

#             break

#     return lst







## Модуль 7 Сортировка и поиск.
## Тема: Сортировка и поиск. Часть 2






## Задание 1








## Написать программу «справочник». Создать два списка
## целых. Один список хранит идентификационные коды,
## второй — телефонные номера. Реализовать меню для
## пользователя:
## Отсортировать по идентификационным кодам;
## Отсортировать по номерам телефона;
## Вывести список пользователей с кодами и телефонами;
## Выход


# lst1 = ['123', '456', '789', '012', '345', '678']
# lst2 = ['+79394593', '+724904480294', '+724940934566', '+7435352525', '+734536346', '+74636326226']

# def insertion_sort(a1:list, a2:list):
#     if (len(a1)!=len(a2)):
#         raise ValueError('len not equals')
#     n = len(a1)
#     for i in range(1, n):
#         x = a1[i]
#         j = i
#         z = a2[i]
#         while j > 0 and a1[j - 1] > x:
#             a1[j] = a1[j - 1]
#             a2[j] = a2[j - 1]
#             j -= 1

#         a1[j] = x
#         a2[j] = z

# insertion_sort(lst1,lst2)
# print(lst1)    
# print(lst2)    
# insertion_sort(lst2,lst1)
# print(lst1)    
# print(lst2)    







# Задание 2
## Написать программу «успеваемость». Пользователь
## вводит 10 оценок студента. Оценки от 1 до 12 Реализовать
## меню для пользователя:
## ■ Вывод оценок (вывод содержимого списка);
## ■ Пересдача экзамена (пользователь вводит номер эле-
## мента списка и новую оценку);
## ■ Выходит ли стипендия (стипендия выходит, если
## средний бал не ниже 10.7);
## ■ Вывод отсортированного списка оценок: по возрас-
## танию или убыванию.
## ■ Выход.









            ## Инициализируйте пустой список для хранения оценок
# grades = []

# ## Предложите пользователю ввести 10 оценок
# for i in range(10):
#     while True:
#         grade = int(input(f"Введите оценку {i+1} (1-12): "))
#         if 1 <= grade <= 12:
#             grades.append(grade)
#             break
#         else:
#             print("Неверная оценка. Пожалуйста, попробуйте снова.")

# ## Определите функцию для вычисления среднего балла
# def calculate_average():
#     return sum(grades) / len(grades)

# ## Определите функцию для проверки того, имеет ли студент право на получение стипендии
# def is_scholarship_eligible():
#     return calculate_average() >= 10.7

# ## Определите функцию для сортировки оценок в порядке возрастания или убывания
# def sort_grades(order):
#     if order == "asc":
#         return sorted(grades)
#     elif order == "desc":
#         return sorted(grades, reverse=True)
#     else:
#         print("Недействительный заказ. Пожалуйста, попробуйте снова.")

# ## Цикл работы главного меню
# while True:
#     print("\nАкадемическое меню выступлений:")
#     print("1. Просмотр оценок")
#     print("2. Пересдать экзамен")
#     print("3. Проверьте право на получение стипендии")
#     print("4. Сортировка оценок")
#     print("5. Выход")
#     choice = input("Введите свой выбор: ")

#     if choice == "1":
#         print("Оценки:", grades)
#     elif choice == "2":
#         index = int(input("Введите номер экзамена для пересдачи (1-10): ")) - 1
#         if 0 <= index < 10:
#             new_grade = int(input("Переход в новый класс (1-12): "))
#             grades[index] = new_grade
#             print("Оценка успешно обновлена!")
#         else:
#             print("Неверный номер экзамена. Пожалуйста, попробуйте снова.")
#     elif choice == "3":
#         if is_scholarship_eligible():
#             print("Студент имеет право на получение стипендии!")
#         else:
#             print("Студент не имеет права на получение стипендии.")
#     elif choice == "4":
#         order = input("Введите порядок сортировки (asc/desc): ")
#         sorted_grades = sort_grades(order)
#         print("Отсортированные сорта:", sorted_grades)
#     elif choice == "5":
#         print("До свидания!")
#         break
#     else:
#         print("Неверный выбор. Пожалуйста, попробуйте снова.")









## Модуль 7 Сортировка и поиск.
## Тема: Сортировка и поиск. Часть 3








## Задание 1
## Есть четыре списка целых. Необходимо их объединить
## в пятом списке. Полученный результат в зависимости от
## выбора пользователя отсортировать по убыванию или
## возрастанию. Найти значение, введенное пользователем,
## с использованием линейного поиска.
## Вывести результат на экран.

## Определите четыре списка целых чисел
# list1 = [1, 2, 3, 4]
# list2 = [5, 6, 7, 8]
# list3 = [9, 10, 11, 12]
# list4 = [13, 14, 15, 16]

# ## Объедините четыре списка в один
# combined_list = list1 + list2 + list3 + list4

# ## Попросите пользователя выбрать порядок сортировки
# print("Выберите порядок сортировки:")
# print("1. Восходящий")
# print("2. Нисходящий")
# choice = int(input("Введите свой выбор: "))

# ## Отсортируйте объединенный список на основе выбора пользователя
# if choice == 1:
#     combined_list.sort()
#     print("Отсортированный список в порядке возрастания:", combined_list)
# elif choice == 2:
#     combined_list.sort(reverse=True)
#     print("Отсортированный список в порядке убывания:", combined_list)
# else:
#     print("Неверный выбор. Выходящий.")

# ## Попросите пользователя ввести значение для поиска
# search_value = int(input("Введите значение для поиска: "))

# ## Выполнять линейный поиск
# found = False
# for i, value in enumerate(combined_list):
#     if value == search_value:
#         found = True
#         print(f"Ценность {search_value} найдено по индексу {i}")
#         break

# if not found:
#     print(f"Ценность {search_value} не найден в списке")








## Задание 2
## Есть четыре списка целых. Необходимо объединить
## в пятом списке только те элементы, которые уникальны
## для каждого списка. Полученный результат в зависимости
## от выбора пользователя отсортировать по убыванию или
## возрастанию. Найти значение, введенное пользователем,
## с использованием бинарного поиска






# def unique_elements(list1, list2, list3, list4):
#     ## Объедините все списки в один
#     combined_list = list1 + list2 + list3 + list4
    
#     ## Найдите уникальные элементы в объединенном списке
#     unique_list = [x for x in combined_list if combined_list.count(x) == 1]
    
#     return unique_list

# def sort_list(unique_list, order):
#     if order == 'asc':
#         return sorted(unique_list)
#     elif order == 'desc':
#         return sorted(unique_list, reverse=True)
#     else:
#         return "Неверный заказ. Пожалуйста, выберите 'asc' или 'desc'."

# def binary_search(sorted_list, target):
#     low = 0
#     high = len(sorted_list) - 1
    
#     while low <= high:
#         mid = (low + high) // 2
#         if sorted_list[mid] == target:
#             return mid
#         elif sorted_list[mid] < target:
#             low = mid + 1
#         else:
#             high = mid - 1
    
#     return -1

# ## Пример использования
# list1 = [1, 2, 3, 4]
# list2 = [3, 4, 5, 6]
# list3 = [5, 6, 7, 8]
# list4 = [7, 8, 9, 10]

# unique_list = unique_elements(list1, list2, list3, list4)
# print("Уникальные элементы:", unique_list)

# order = input("Введите 'asc' для возрастания или 'desc' для убывания: ")
# sorted_list = sort_list(unique_list, order)
# print("Отсортированный список:", sorted_list)

# target = int(input("Введите номер для поиска: "))
# index = binary_search(sorted_list, target)

# if index != -1:
#     print("Элемент, найденный по индексу", index)
# else:
#     print("Элемент не найден")

## Модуль 8 Кортежи, множества, словари
## Тема: Кортежи, множества, словари. Часть 1






## Задание 1
## Есть три кортежа целых чисел необходимо найти
## элементы, которые есть во всех кортежах






# # t1 = (1, 2, 3, 4, 5)
# t2 = (4, 5, 6, 7, 8)
# t3 = (4, 5, 9, 10, 11)

# s1 = set(t1)
# s2 = set(t2)
# s3 = set(t3)

# common_elements = s1 & s2 & s3

# print(common_elements)  # {4, 5}






## Задание 2
## Есть три кортежа целых чисел необходимо найти
## элементы, которые уникальны для каждого списка.






# t1 = (1, 2, 3, 4, 5)
# t2 = (4, 5, 6, 7, 8)
# t3 = (4, 5, 9, 10, 11)

# s1 = set(t1)
# s2 = set(t2)
# s3 = set(t3)

# unique_in_t1 = s1 - s2 - s3
# unique_in_t2 = s2 - s1 - s3
# unique_in_t3 = s3 - s1 - s2

# print("Уникальные элементы в t1:", unique_in_t1)  # {1, 2, 3}
# print("Уникальные элементы в t2:", unique_in_t2)  # {6, 7, 8}
# print("Уникальные элементы в t3:", unique_in_t3)  # {9, 10, 11}





## Задание 3
## Есть три кортежа целых чисел необходимо найти эле-
## менты, которые есть в каждом из кортежей и находятся
## в каждом из кортежей на той же позиции.





# t1 = (1, 2, 3, 4, 5)
# t2 = (1, 2, 3, 6, 7)
# t3 = (1, 2, 3, 8, 9)

# common_elements = [x for x, y, z in zip(t1, t2, t3) if x == y == z]

# print(common_elements)  # [1, 2, 3]






## Модуль 8 Кортежи, множества, словари
## Тема: Кортежи, множества, словари. Часть 2






## Задание 1
## Создайте программу, хранящую информацию о вели-
## ких баскетболистах. Нужно хранить ФИО баскетболиста и
## его рост. Требуется реализовать возможность добавления,
## удаления, поиска, замены данных. Используйте словарь
## для хранения информации.







# Создаем пустой словарь для хранения информации о баскетболистах
# basketball_players = {}

# def add_player():
#     # Добавляем нового баскетболиста
#     name = input("Введите ФИО баскетболиста: ")
#     height = int(input("Введите рост баскетболиста (в см): "))
#     basketball_players[name] = height
#     print(f"Баскетболист {name} добавлен в список!")

# def delete_player():
#     # Удаляем баскетболиста из списка
#     name = input("Введите ФИО баскетболиста для удаления: ")
#     if name in basketball_players:
#         del basketball_players[name]
#         print(f"Баскетболист {name} удален из списка!")
#     else:
#         print(f"Баскетболист {name} не найден в списке!")

# def search_player():
#     # Ищем баскетболиста по ФИО
#     name = input("Введите ФИО баскетболиста для поиска: ")
#     if name in basketball_players:
#         print(f"Баскетболист {name} найден! Его рост: {basketball_players[name]} см")
#     else:
#         print(f"Баскетболист {name} не найден в списке!")

# def replace_player():
#     # Заменяем информацию о баскетболисте
#     name = input("Введите ФИО баскетболиста для замены: ")
#     if name in basketball_players:
#         new_height = int(input("Введите новый рост баскетболиста (в см): "))
#         basketball_players[name] = new_height
#         print(f"Информация о баскетболисте {name} обновлена!")
#     else:
#         print(f"Баскетболист {name} не найден в списке!")

# def print_players():
#     # Выводим список всех баскетболистов
#     print("Список баскетболистов:")
#     for name, height in basketball_players.items():
#         print(f"{name} - {height} см")

# while True:
#     print("Меню:")
#     print("1. Добавить баскетболиста")
#     print("2. Удалить баскетболиста")
#     print("3. Найти баскетболиста")
#     print("4. Заменить информацию о баскетболисте")
#     print("5. Вывести список баскетболистов")
#     print("6. Выход")
#     choice = int(input("Выберите пункт меню: "))
#     if choice == 1:
#         add_player()
#     elif choice == 2:
#         delete_player()
#     elif choice == 3:
#         search_player()
#     elif choice == 4:
#         replace_player()
#     elif choice == 5:
#         print_players()
#     elif choice == 6:
#         break
#     else:
#         print("Неверный выбор!")







## Задание 2
## Создайте программу «Англо-русский словарь».
## Нужно хранить слово на английском языке и его перевод
## на французский. Требуется реализовать возможность до-
## бавления, удаления, поиска, замены данных. Используйте
## словарь для хранения информации.






# dictionary_wor = {}

# def add_word():
#     # Добавляем новое слово
#     name = input("Введите слово на русском: ")
#     height = input("Введите слово на английском: ")
#     dictionary_wor[name] = height
#     print(f"Слово {name} добавлено в список!")

# def delete_word():
#     # Удаляем слово из списка
#     name = input("Введите слово для удаления: ")
#     if name in dictionary_wor:
#         del dictionary_wor[name]
#         print(f"Слово {name} удалено из списка!")
#     else:
#         print(f"Слово {name} не найдено в списке!")

# def search_word():
#     # Ищем слово на русском
#     name = input("Введите слово для поиска: ")
#     if name in dictionary_wor:
#         print(f"Слово {name} найдено! Это слово по-английски: {dictionary_wor[name]} ")
#     else:
#         print(f"Слово {name} не найдено в списке!")

# def replace_word():
#     # Заменяем информацию о слове
#     name = input("Введите слово на русском для замены: ")
#     if name in dictionary_wor:
#         new_height = input("Введите новое слово на английском: ")
#         dictionary_wor[name] = new_height
#         print(f"Информация о слове {name} обновлена!")
#     else:
#         print(f"Слово {name} не найдено в списке!")

# def print_word():
#     # Выводим список всех слов
#     print("Список слов:")
#     for name, height in dictionary_wor.items():
#         print(f"{name} - {height} ")

# while True:
#     print("Меню:")
#     print("1. Добавить слово")
#     print("2. Удалить слово")
#     print("3. Найти слово")
#     print("4. Заменить информацию о слове")
#     print("5. Вывести список слов")
#     print("6. Выход")
#     choice = int(input("Выберите пункт меню: "))

#     if choice == 1:
#         add_word()
#     elif choice == 2:
#         delete_word()
#     elif choice == 3:
#         search_word()
#     elif choice == 4:
#         replace_word()
#     elif choice == 5:
#         print_word()
#     elif choice == 6:
#         break
#     else:
#         print("Неверный выбор!")






## Задание 3
##  Создайте программу «Фирма». Нужно хранить ин-
##  формацию о человеке: ФИО, телефон, рабочий email,
##  название должности, номер кабинета, skype. Требуется
##  реализовать возможность добавления, удаления, поис-
##  ка, замены данных. Используйте словарь для хранения
##  информации.







# Firm_human = {}

# Firm_human = {}

# def add_human():
#     # Добавляем нового сотрудника
#     name = input("Введите ФИО сотрудника: ")
#     phone = input("Введите телефон сотрудника: ")
#     email = input("Введите email сотрудника: ")
#     position = input("Введите должность сотрудника: ")
#     cabinet = input("Введите номер кабинета сотрудника: ")
#     skype = input("Введите skype сотрудника: ")
#     Firm_human[name] = {
#         "телефон": phone,
#         "email": email,
#         "должность": position,
#         "кабинет": cabinet,
#         "skype": skype
#     }
#     print(f"Сотрудник {name} добавлен в список!")

# def delete_human():
#     # Удаляем сотрудника из списка
#     name = input("Введите ФИО сотрудника для удаления: ")
#     if name in Firm_human:
#         del Firm_human[name]
#         print(f"Сотрудник {name} удален из списка!")
#     else:
#         print(f"Сотрудник {name} не найден в списке!")

# def search_human():
#     # Ищем сотрудника по ФИО
#     name = input("Введите ФИО сотрудника для поиска: ")
#     if name in Firm_human:
#         print(f"Сотрудник {name} найден!")
#         print(f"Телефон: {Firm_human[name]['телефон']}")
#         print(f"Email: {Firm_human[name]['email']}")
#         print(f"Должность: {Firm_human[name]['должность']}")
#         print(f"Кабинет: {Firm_human[name]['кабинет']}")
#         print(f"Skype: {Firm_human[name]['skype']}")
#     else:
#         print(f"Сотрудник {name} не найден в списке!")

# def replace_human():
#     # Заменяем информацию о сотруднике
#     name = input("Введите ФИО сотрудника для замены: ")
#     if name in Firm_human:
#         phone = input("Введите новый телефон сотрудника: ")
#         email = input("Введите новый email сотрудника: ")
#         position = input("Введите новую должность сотрудника: ")
#         cabinet = input("Введите новый номер кабинета сотрудника: ")
#         skype = input("Введите новый skype сотрудника: ")
#         Firm_human[name] = {
#             "телефон": phone,
#             "email": email,
#             "должность": position,
#             "кабинет": cabinet,
#             "skype": skype
#         }
#         print(f"Информация о сотруднике {name} обновлена!")
#     else:
#         print(f"Сотрудник {name} не найден в списке!")

# def print_human():
#     # Выводим список всех сотрудников
#     print("Список сотрудников:")
#     for name, info in Firm_human.items():
#         print(f"{name}:")
#         print(f"Телефон: {info['телефон']}")
#         print(f"Email: {info['email']}")
#         print(f"Должность: {info['должность']}")
#         print(f"Кабинет: {info['кабинет']}")
#         print(f"Skype: {info['skype']}")
#         print()

# while True:
#     print("Меню:")
#     print("1. Добавить сотрудника")
#     print("2. Удалить сотрудника")
#     print("3. Найти сотрудника")
#     print("4. Заменить информацию о сотруднике")
#     print("5. Вывести список сотрудников")
#     print("6. Выход")
#     choice = int(input("Выберите пункт меню: "))

#     if choice == 1:
#         add_human()
#     elif choice == 2:
#         delete_human()
#     elif choice == 3:
#         search_human()
#     elif choice == 4:
#         replace_human()
#     elif choice == 5:
#         print_human()
#     elif choice == 6:
#         break
#     else:
#         print("Неверный выбор!")






## Задание 4
## Создайте программу «Книжная коллекция». Нужно
## хранить информацию о книгах: автор, название книги,
## жанр, год выпуска, количество страниц, издательство.
## Требуется реализовать возможность добавления, удале-
## ния, поиска, замены данных. Используйте словарь для
## хранения информации.







# book_collection = {}

# def add_book():
#     # Добавляем новую книгу
#     title = input("Введите название книги: ")
#     author = input("Введите автора книги: ")
#     genre = input("Введите жанр книги: ")
#     year = input("Введите год выпуска книги: ")
#     pages = input("Введите количество страниц книги: ")
#     publisher = input("Введите издательство книги: ")
#     book_collection[title] = {
#         "author": author,
#         "genre": genre,
#         "year": year,
#         "pages": pages,
#         "publisher": publisher
#     }
#     print(f"Книга {title} добавлена в коллекцию!")

# def delete_book():
#     # Удаляем книгу из коллекции
#     title = input("Введите название книги для удаления: ")
#     if title in book_collection:
#         del book_collection[title]
#         print(f"Книга {title} удалена из коллекции!")
#     else:
#         print(f"Книга {title} не найдена в коллекции!")

# def search_book():
#     # Ищем книгу по названию
#     title = input("Введите название книги для поиска: ")
#     if title in book_collection:
#         print(f"Книга {title} найдена!")
#         print(f"Автор: {book_collection[title]['author']}")
#         print(f"Жанр: {book_collection[title]['genre']}")
#         print(f"Год выпуска: {book_collection[title]['year']}")
#         print(f"Количество страниц: {book_collection[title]['pages']}")
#         print(f"Издательство: {book_collection[title]['publisher']}")
#     else:
#         print(f"Книга {title} не найдена в коллекции!")

# def replace_book():
#     # Заменяем информацию о книге
#     title = input("Введите название книги для замены: ")
#     if title in book_collection:
#         author = input("Введите нового автора книги: ")
#         genre = input("Введите новый жанр книги: ")
#         year = input("Введите новый год выпуска книги: ")
#         pages = input("Введите новое количество страниц книги: ")
#         publisher = input("Введите новое издательство книги: ")
#         book_collection[title] = {
#             "author": author,
#             "genre": genre,
#             "year": year,
#             "pages": pages,
#             "publisher": publisher
#         }
#         print(f"Информация о книге {title} обновлена!")
#     else:
#         print(f"Книга {title} не найдена в коллекции!")

# def print_books():
#     # Выводим список всех книг
#     print("Список книг:")
#     for title, book in book_collection.items():
#         print(f"{title}:")
#         print(f"Автор: {book['author']}")
#         print(f"Жанр: {book['genre']}")
#         print(f"Год выпуска: {book['year']}")
#         print(f"Количество страниц: {book['pages']}")
#         print(f"Издательство: {book['publisher']}")
#         print()

# while True:
#     print("Меню:")
#     print("1. Добавить книгу")
#     print("2. Удалить книгу")
#     print("3. Найти книгу")
#     print("4. Заменить информацию о книге")
#     print("5. Вывести список книг")
#     print("6. Выход")
#     choice = int(input("Выберите пункт меню: "))

#     if choice == 1:
#         add_book()
#     elif choice == 2:
#         delete_book()
#     elif choice == 3:
#         search_book()
#     elif choice == 4:
#         replace_book()
#     elif choice == 5:
#         print_books()
#     elif choice == 6:
#         break
#     else:
#         print("Неверный выбор!")

 #Модуль 5 Файлы.Файлы.(Часть 1)






## Задание 1
## Дано два текстовых файла. Выяснить, совпадают ли
## их строки. Если нет, то вывести несовпадающую строку
## из каждого файла.




# import os

# def compare_files(file1_name, file2_name):
#     """
#     Сравнивает строки двух текстовых файлов.

#     Args:
#         file1_name (str): Имя первого файла.
#         file2_name (str): Имя второго файла.

#     Returns:
#         None
#     """
#     try:
#         with open(file1_name, 'r', encoding='utf-8') as file1, open(file2_name, 'r', encoding='utf-8') as file2:
#             file1_lines = file1.readlines()
#             file2_lines = file2.readlines()

#             # Сравниваем количество строк в файлах
#             if len(file1_lines) != len(file2_lines):
#                 print("Файлы имеют разное количество строк.")
#                 print(f"Файл {file1_name} имеет {len(file1_lines)} строк.")
#                 print(f"Файл {file2_name} имеет {len(file2_lines)} строк.")
#                 return

#             # Сравниваем строки
#             not_match = False
#             for i, (line1, line2) in enumerate(zip(file1_lines, file2_lines), start=1):
#                 if line1.strip() != line2.strip():
#                     not_match = True
#                     print(f"Несовпадающие строки в строке {i}:")
#                     print(f"Файл {file1_name}: {line1.strip()}")
#                     print(f"Файл {file2_name}: {line2.strip()}")
#                     print()

#             if not not_match:
#                 print("Все строки совпадают.")

#     except FileNotFoundError:
#         print("Один из файлов не найден. Пожалуйста, проверьте путь к файлам.")

# def main():
#     while True:
#         print("Меню:")
#         print("1. Сравнить файлы")
#         print("2. Выход")
#         choice = input("Выберите действие: ")

#         if choice == "1":
#             file1_name = input("Введите полный путь к первому файлу: ")
#             file2_name = input("Введите полный путь к второму файлу: ")

#             # Проверяем, существуют ли файлы
#             if not os.path.exists(file1_name):
#                 print(f"Файл {file1_name} не найден.")
#                 continue
#             if not os.path.exists(file2_name):
#                 print(f"Файл {file2_name} не найден.")
#                 continue

#             compare_files(file1_name, file2_name)
#         elif choice == "2":
#             print("Выход из программы.")
#             break
#         else:
#             print("Неправильный выбор. Пожалуйста, выберите действие из меню.")

# if __name__ == "__main__":
#     main()







##     Дан текстовый файл. Необходимо создать новый файл
## и записать в него следующую статистику по исходному
## файлу:
## ■ Количество символов;
## ■ Количество строк;
## ■ Количество гласных букв;
## ■ Количество согласных букв;
## ■ Количество цифр.





# def count_chars(file_name):
#     with open(file_name, 'r', encoding='utf-8') as file:
#         text = file.read()
#         char_count = len(text)
#         line_count = len(text.splitlines())
#         vowel_count = sum(1 for char in text.lower() if char in 'aeiouy')
#         consonant_count = sum(1 for char in text.lower() if char.isalpha() and char not in 'aeiouy')
#         digit_count = sum(1 for char in text if char.isdigit())

#     with open('stats.txt', 'w', encoding='utf-8') as stats_file:
#         stats_file.write(f'Количество символов: {char_count}\n')
#         stats_file.write(f'Количество строк: {line_count}\n')
#         stats_file.write(f'Количество гласных букв: {vowel_count}\n')
#         stats_file.write(f'Количество согласных букв: {consonant_count}\n')
#         stats_file.write(f'Количество цифр: {digit_count}\n')

# def main():
#     file_name = input("Введите имя файла для анализа: ")
#     count_chars(file_name)
#     print("Статистика записана в файл stats.txt.")

# if __name__ == "__main__":
#     main()






## Задание 3
## Дан текстовый файл. Удалить из него последнюю
## строку. Результат записать в другой файл.






# def remove_last_line(input_file_name, output_file_name):
#     with open(input_file_name, 'r', encoding='utf-8') as input_file:
#         lines = input_file.readlines()
#         lines = lines[:-1]  # удалить последнюю строку

#     with open(output_file_name, 'w', encoding='utf-8') as output_file:
#         output_file.writelines(lines)

# def main():
#     input_file_name = input("Введите имя файла для редактирования: ")
#     output_file_name = input("Введите имя файла для результата: ")
#     remove_last_line(input_file_name, output_file_name)
#     print("Результат записан в файл", output_file_name)

# if __name__ == "__main__":
#     main()







## Задание 4
## Дан текстовый файл. Найти длину самой длинной
## строки.






# def find_longest_line_length(file_name):
#     with open(file_name, 'r', encoding='utf-8') as file:
#         lines = file.readlines()
#         longest_line_length = max(len(line.strip()) for line in lines)

#     print(f"Длина самой длинной строки: {longest_line_length}")

# def main():
#     file_name = input("Введите имя файла для анализа: ")
#     find_longest_line_length(file_name)

# if __name__ == "__main__":
#     main()







# Задание 5
# Дан текстовый файл. Посчитать сколько раз в нем
# встречается заданное пользователем слово.






# def count_word_occurrences(file_name, word):
#     with open(file_name, 'r', encoding='utf-8') as file:
#         text = file.read().lower()
#         word = word.lower()
#         occurrences = text.count(word)

#     print(f"Слово '{word}' встречается {occurrences} раз(а)")

# def main():
#     file_name = input("Введите имя файла для анализа: ")
#     word = input("Введите слово для поиска: ")
#     count_word_occurrences(file_name, word)

# if __name__ == "__main__":
#     main()






## Задание 6
## Дан текстовый файл. Найти и заменить в нем задан-
## ное слово. Что искать и на что заменять определяется
## пользователем.







## №1



# def replace_word(file_name, old_word, new_word):
#     with open(file_name, 'r', encoding='utf-8') as file:
#         text = file.read().lower()
#         old_word = old_word.lower()
#         new_word = new_word.lower()
#         text = text.replace(old_word, new_word)
#         with open(file_name, 'w', encoding='utf-8') as file:
#             file.write(text)
#     print(f"Слово '{old_word}' заменено на '{new_word}'")
# def main():
#     file_name = input("Введите имя файла для редактирования: ")
#     old_word = input("Введите слово для замены: ")
#     new_word = input("Введите новое слово: ")
#     replace_word(file_name, old_word, new_word)
# if __name__ == "__main__":
#     main()







## №2



# def replace_word_in_file(file_name, old_word, new_word):
#     with open(file_name, 'r', encoding='utf-8') as file:
#         text = file.read()

#     new_text = text.replace(old_word, new_word)

#     with open(file_name, 'w', encoding='utf-8') as file:
#         file.write(new_text)

#     print(f"Слово '{old_word}' заменено на '{new_word}' в файле {file_name}")

# def main():
#     file_name = input("Введите имя файла для редактирования: ")
#     old_word = input("Введите слово для замены: ")
#     new_word = input("Введите новое слово: ")
#     replace_word_in_file(file_name, old_word, new_word)

# if __name__ == "__main__":
#     main()







## Модуль 5 Файлы.
## Тема: Файлы. Часть 2







## Задание 1
## Напишите информационную систему «Сотрудники».
## Программа должна обеспечивать ввод данных, редакти-
## рование данных сотрудника, удаление сотрудника, поиск
## сотрудника по фамилии, вывод информации обо всех
## сотрудниках, указанного возраста, или фамилия которых
## начинается на указанную букву. Организуйте возможность
## сохранения найденной информации в файл. Также весь
## список сотрудников сохраняется в файл (при выходе из
## программы — автоматически, в процессе исполнения
## программы — по команде пользователя). При старте
## программы происходит загрузка списка сотрудников из
## указанного пользователем файла.






# class Employee:
#     def __init__(self, surname, name, age):
#         self.surname = surname
#         self.name = name
#         self.age = age

#     def __str__(self):
#         return f"{self.surname} {self.name}, {self.age} лет"

# class EmployeeSystem:
#     def __init__(self, file_name):
#         self.employees = self.load_employees_from_file(file_name)

#     def load_employees_from_file(self, file_name):
#         try:
#             with open(file_name, 'r', encoding='utf-8') as file:
#                 employees = []
#                 for line in file:
#                     surname, name, age = line.strip().split(',')
#                     employees.append(Employee(surname, name, int(age)))
#                 return employees
#         except FileNotFoundError:
#             return []

#     def save_employees_to_file(self, file_name):
#         with open(file_name, 'w', encoding='utf-8') as file:
#             for employee in self.employees:
#                 file.write(f"{employee.surname},{employee.name},{employee.age}\n")

#     def add_employee(self, surname, name, age):
#         self.employees.append(Employee(surname, name, age))

#     def edit_employee(self, surname, name, age):
#         for employee in self.employees:
#             if employee.surname == surname:
#                 employee.name = name
#                 employee.age = age
#                 return
#         print("Сотрудник не найден")

#     def delete_employee(self, surname):
#         for employee in self.employees:
#             if employee.surname == surname:
#                 self.employees.remove(employee)
#                 return
#         print("Сотрудник не найден")

#     def find_employees_by_surname(self, surname):
#         return [employee for employee in self.employees if employee.surname.startswith(surname)]

#     def find_employees_by_age(self, age):
#         return [employee for employee in self.employees if employee.age == age]

#     def print_employees(self, employees):
#         for employee in employees:
#             print(employee)

# def main():
#     file_name = input("Введите имя файла для загрузки списка сотрудников: ")
#     system = EmployeeSystem(file_name)

#     while True:
#         print("Меню:")
#         print("1. Добавить сотрудника")
#         print("2. Редактировать сотрудника")
#         print("3. Удалить сотрудника")
#         print("4. Найти сотрудника по фамилии")
#         print("5. Найти сотрудника по возрасту")
#         print("6. Вывести информацию обо всех сотрудниках")
#         print("7. Сохранить список сотрудников в файл")
#         print("8. Выход")

#         choice = input("Введите номер пункта меню: ")

#         if choice == "1":
#             surname = input("Введите фамилию: ")
#             name = input("Введите имя: ")
#             age = int(input("Введите возраст: "))
#             system.add_employee(surname, name, age)
#         elif choice == "2":
#             surname = input("Введите фамилию: ")
#             name = input("Введите имя: ")
#             age = int(input("Введите возраст: "))
#             system.edit_employee(surname, name, age)
#         elif choice == "3":
#             surname = input("Введите фамилию: ")
#             system.delete_employee(surname)
#         elif choice == "4":
#             surname = input("Введите фамилию: ")
#             employees = system.find_employees_by_surname(surname)
#             system.print_employees(employees)
#         elif choice == "5":
#             age = int(input("Введите возраст: "))
#             employees = system.find_employees_by_age(age)
#             system.print_employees(employees)
#         elif choice == "6":
#             system.print_employees(system.employees)
#         elif choice == "7":
#             file_name = input("Введите имя файла для сохранения списка сотрудников: ")
#             system.save_employees_to_file(file_name)
#         elif choice == "8":
#             system.save_employees_to_file(file_name)
#             break
#         else:
#             print("Неверный выбор")

# if __name__ == "__main__":
#     main()






##     Шаг 1: Определение класса Employee

## Код определяет класс Employee с тремя атрибутами: фамилией, именем и возрастом. Метод __init__ инициализирует эти атрибуты при создании экземпляра класса. Метод __str__ возвращает строковое представление сотрудника в формате "Фамилия, имя, возраст, годы".

## Шаг 2: Определение класса EmployeeSystem

## В коде определяется класс EmployeeSystem, который управляет списком сотрудников. Метод __init__ инициализирует список сотрудников, загружая их из файла, указанного параметром file_name. Метод load_employees_from_file считывает файл и создает экземпляр класса Employee для каждой строки в файле.

## Шаг 3: Определение методов для класса EmployeeSystem

## В коде определено несколько методов для класса EmployeeSystem:

## add_employee: добавляет нового сотрудника в список
## edit_employee: редактирует существующего сотрудника в списке
## delete_employee: удаляет сотрудника из списка
## find_employees_by_surname: находит сотрудников по фамилии
## find_employees_by_age: находит сотрудников по возрасту
## print_employees: печатает список сотрудников
## save_employees_to_file: сохраняет список сотрудников в файл
## Шаг 4: Определение основной функции

## Код определяет основную функцию, которая запускает программу. Функция:

## Просит пользователя ввести имя файла для загрузки списка сотрудников
## Создает экземпляр класса EmployeeSystem с указанным именем файла
## Переходит в цикл, в котором пользователю повторно предлагается выбрать действие из меню
## Шаг 5: Цикл меню

## В цикле меню пользователю повторно предлагается выбрать действие из следующего меню:

## Добавить сотрудника
## Отредактировать сотрудника
## Удалить сотрудника
## Поиск сотрудников по фамилии
## Поиск сотрудников по возрасту
## Вывести всех сотрудников
## Сохранить сотрудников в файл
## Выход
## В зависимости от выбора пользователя программа выполняет соответствующее действие, используя методы, определенные в классе EmployeeSystem.

## Шаг 6: Сохранение сотрудников в файл

## Когда пользователь выбирает сохранение сотрудников в файл, программа запрашивает имя сотрудника.выберите файл для сохранения, а затем вызовите метод save_employees_to_file, чтобы сохранить список сотрудников в указанном файле.

## Шаг 7: Выход из программы

## Когда пользователь решает выйти из программы, программа сохраняет список сотрудников в файл, указанный в переменной file_name, а затем завершает цикл.

## Это общий обзор того, что делает код на высоком уровне! Дайте мне знать, если у вас возникнут какие-либо конкретные вопросы по поводу любого из этих шагов.







# Модуль 10. Обьектно-ориентированное программирование
#        Тема: Множественное наследование.
# Полиморфизм. Реализация магических методов. Часть 6








## Задание 1
## Создать базовый класс Фигура с методом для подсчета
## площади. Создать производные классы: прямоугольник,
## круг, прямоугольный треугольник, трапеция со своими
## методами для подсчета площади.





# import math

# ## Базовый класс Фигура
# class Figure:
#     def __init__(self):
#         pass

#     def area(self):
#         pass

# ## Производный класс Прямоугольник
# class Rectangle(Figure):
#     def __init__(self, width, height):
#         self.width = width
#         self.height = height

#     def area(self):
#         return self.width * self.height

# ## Производный класс Круг
# class Circle(Figure):
#     def __init__(self, radius):
#         self.radius = radius

#     def area(self):
#         return math.pi * (self.radius ** 2)

# ##Производный класс Прямоугольный треугольник
# class RightTriangle(Figure):
#     def __init__(self, base, height):
#         self.base = base
#         self.height = height

#     def area(self):
#         return 0.5 * self.base * self.height

# ## Производный класс Трапеция
# class Trapezoid(Figure):
#     def __init__(self, base1, base2, height):
#         self.base1 = base1
#         self.base2 = base2
#         self.height = height

#     def area(self):
#         return 0.5 * (self.base1 + self.base2) * self.height

# ## Пример использования
# rectangle = Rectangle(4, 5)
# print(f"Площадь прямоугольника: {rectangle.area()}")

# circle = Circle(3)
# print(f"Площадь круга: {circle.area()}")

# right_triangle = RightTriangle(3, 4)
# print(f"Площадь прямоугольного треугольника: {right_triangle.area()}")

# trapezoid = Trapezoid(3, 5, 4)
# print(f"Площадь трапеции: {trapezoid.area()}")







# ## Задание 2
# ## Для классов из задания 1 нужно переопределить маги-
# ## ческие методы int(возвращает площадь) и str (возвращает
# ## информацию о фигуре).
# import math






# # Базовый класс Фигура
# class Figure:
#     def __init__(self):
#         pass

#     def area(self):
#         pass

#     def __int__(self):
#         return int(self.area())

#     def __str__(self):
#         pass

# ## Производный класс Прямоугольник
# class Rectangle(Figure):
#     def __init__(self, width, height):
#         self.width = width
#         self.height = height

#     def area(self):
#         return self.width * self.height

#     def __str__(self):
#         return f"Прямоугольник: ширина = {self.width}, высота = {self.height}, площадь = {self.area()}"

# ## Производный класс Круг
# class Circle(Figure):
#     def __init__(self, radius):
#         self.radius = radius

#     def area(self):
#         return math.pi * (self.radius ** 2)

#     def __str__(self):
#         return f"Круг: радиус = {self.radius}, площадь = {self.area()}"

# ## Производный класс Прямоугольный треугольник
# class RightTriangle(Figure):
#     def __init__(self, base, height):
#         self.base = base
#         self.height = height

#     def area(self):
#         return 0.5 * self.base * self.height

#     def __str__(self):
#         return f"Прямоугольный треугольник: основание = {self.base}, высота = {self.height}, площадь = {self.area()}"

# ## Производный класс Трапеция
# class Trapezoid(Figure):
#     def __init__(self, base1, base2, height):
#         self.base1 = base1
#         self.base2 = base2
#         self.height = height

#     def area(self):
#         return 0.5 * (self.base1 + self.base2) * self.height

#     def __str__(self):
#         return f"Трапеция: основания = {self.base1} и {self.base2}, высота = {self.height}, площадь = {self.area()}"

# ## Пример использования
# rectangle = Rectangle(4, 5)
# print(int(rectangle))  ## Выводит площадь прямоугольника
# print(rectangle)  # Выводит информацию о прямоугольнике

# circle = Circle(3)
# print(int(circle))  ## Выводит площадь круга
# print(circle)  ## Выводит информацию о круге

# right_triangle = RightTriangle(3, 4)
# print(int(right_triangle))  ## Выводит площадь прямоугольного треугольника
# print(right_triangle)  ## Выводит информацию о прямоугольном треугольнике

# trapezoid = Trapezoid(3, 5, 4)
# print(int(trapezoid))  ## Выводит площадь трапеции
# print(trapezoid)  ## Выводит информацию о трапеции







# ## Задание 3
# ## Создайте базовый класс Shape для рисования плоских
# ## фигур.
# ## Определите методы:
# ## ■ Show() — вывод на экран информации о фигуре;
# ## ■ Save() — сохранение фигуры в файл;
# ## ■ Load() — считывание фигуры из файла.
# ## Определите производные классы:
# ## ■ Square — квадрат, который характеризуется коорди-
# ## натами левого верхнего угла и длиной стороны;
# ## ■ Rectangle — прямоугольник с заданными координа-
# ## тами верхнего левого угла и размерами;
# ## ■ Circle — окружность с заданными координатами цен-
# ## тра и радиусом;
# ## ■ Ellipse — эллипс с заданными координатами верхнего
# ## угла описанного вокруг него прямоугольника со сто-
# ## ронами, параллельными осям координат, и размерами
# ## этого прямоугольника.
# ## Создайте список фигур, сохраните фигуры в файл,
# ## загрузите в другой список и отобразите информацию о
# ## каждой из фигур.

# import json

# ## Базовый класс Shape
# class Shape:
#     def __init__(self):
#         pass

#     def show(self):
#         pass

#     def save(self, filename):
#         with open(filename, 'a') as file:
#             json.dump(self.__dict__, file)
#             file.write('\n')

#     @classmethod
#     def load(cls, filename):
#         shapes = []
#         with open(filename, 'r') as file:
#             for line in file:
#                 shape_dict = json.loads(line)
#                 shape = cls()
#                 shape.__dict__.update(shape_dict)
#                 shapes.append(shape)
#         return shapes

# ## Производный класс Square
# class Square(Shape):
#     def __init__(self, x, y, side):
#         self.x = x
#         self.y = y
#         self.side = side

#     def show(self):
#         print(f"Квадрат: ({self.x}, {self.y}), сторона = {self.side}")

# ## Производный класс Rectangle
# class Rectangle(Shape):
#     def __init__(self, x, y, width, height):
#         self.x = x
#         self.y = y
#         self.width = width
#         self.height = height

#     def show(self):
#         print(f"Прямоугольник: ({self.x}, {self.y}), ширина = {self.width}, высота = {self.height}")

# ## Производный класс Circle
# class Circle(Shape):
#     def __init__(self, x, y, radius):
#         self.x = x
#         self.y = y
#         self.radius = radius

#     def show(self):
#         print(f"Окружность: ({self.x}, {self.y}), радиус = {self.radius}")

# ## Производный класс Ellipse
# class Ellipse(Shape):
#     def __init__(self, x, y, width, height):
#         self.x = x
#         self.y = y
#         self.width = width
#         self.height = height

#     def show(self):
#         print(f"Эллипс: ({self.x}, {self.y}), ширина = {self.width}, высота = {self.height}")

# ## Создание списка фигур
# shapes = [
#     Square(1, 2, 3),
#     Rectangle(4, 5, 6, 7),
#     Circle(8, 9, 10),
#     Ellipse(11, 12, 13, 14)
# ]

# ## Сохранение фигур в файл
# for shape in shapes:
#     shape.save('shapes.txt')

# ## Загрузка фигур из файла
# loaded_shapes = []
# with open('shapes.txt', 'r') as file:
#     for line in file:
#         shape_dict = json.loads(line)
#         if 'side' in shape_dict:
#             shape = Square(0, 0, 0)
#         elif 'width' in shape_dict and 'height' in shape_dict:
#             if 'radius' not in shape_dict:
#                 shape = Rectangle(0, 0, 0, 0)
#             else:
#                 shape = Ellipse(0, 0, 0, 0)
#         else:
#             shape = Circle(0, 0, 0)
#         shape.__dict__.update(shape_dict)
#         loaded_shapes.append(shape)

# ## Отображение информации о каждой фигуре
# for shape in loaded_shapes:
#     shape.show()






## Модуль 10. Обьектно-ориентированное программирование
##            Тема:наследование.







#  Задание 1
#  Создайте класс Device, который содержит информа-
#  цию об устройстве.
#  С помощью механизма наследования, реализуйте класс
# CoffeeMachine (содержит информацию о кофемашине),
#  класс Blender (содержит информацию о блендере), класс
#  MeatGrinder (содержит информацию о мясорубке).
#  Каждый из классов должен содержать необходимые
#  для работы методы.







# #№1
# class Device:
#     def __init__(self, name, power, voltage):
#         """
#         Инициализация устройства

#         :param name: Название устройства
#         :param power: Мощность устройства
#         :param voltage: Напряжение устройства
#         """
#         self.name = name
#         self.power = power
#         self.voltage = voltage

#     def get_info(self):
#         """
#         Получение информации об устройстве

#         :return: Информация об устройстве
#         """
#         return f"Устройство: {self.name}, Мощность: {self.power} Вт, Напряжение: {self.voltage} В"

#     def turn_on(self):
#         """
#         Включение устройства
#         """
#         print(f"{self.name} включен")

#     def turn_off(self):
#         """
#         Выключение устройства
#         """
#         print(f"{self.name} выключен")

# device = Device("Philips", 300, 220)
# print(device.get_info())
# device.turn_on()
# device.turn_off()



# #№2
# class CoffeeMachine(Device):
#     def __init__(self, name, power, voltage, coffee_types):
#         """
#         Инициализация кофемашины

#         :param name: Название кофемашины
#         :param power: Мощность кофемашины
#         :param voltage: Напряжение кофемашины
#         :param coffee_types: Типы кофе, которые может приготовить кофемашина
#         """
#         super().__init__(name, power, voltage)
#         self.coffee_types = coffee_types

#     def make_coffee(self, coffee_type):
#         """
#         Приготовление кофе

#         :param coffee_type: Тип кофе
#         """
#         if coffee_type in self.coffee_types:
#             print(f"Приготовлен {coffee_type} кофе")
#         else:
#             print("Кофемашина не может приготовить такой тип кофе")

#     def get_coffee_types(self):
#         """
#         Получение списка доступных типов кофе

#         :return: Список доступных типов кофе
#         """
#         return self.coffee_types

# coffee_machine = CoffeeMachine("Philips", 1200, 220, ["Эспрессо", "Капучино", "Латте"])
# print(coffee_machine.get_info())
# coffee_machine.turn_on()
# coffee_machine.make_coffee




# #№3
# class Blender(Device):
#     def __init__(self, name, power, voltage, speed_modes):
#         """
#         Инициализация блендера

#         :param name: Название блендера
#         :param power: Мощность блендера
#         :param voltage: Напряжение блендера
#         :param speed_modes: Режимы скорости блендера
#         """
#         super().__init__(name, power, voltage)
#         self.speed_modes = speed_modes

#     def blend(self, speed_mode):
#         """
#         Взбивание

#         :param speed_mode: Режим скорости
#         """
#         if speed_mode in self.speed_modes:
#             print(f"Взбивание на скорости {speed_mode}")
#         else:
#             print("Блендер не имеет такого режима скорости")

#     def get_speed_modes(self):
#         """
#         Получение списка доступных режимов скорости

#         :return: Список доступных режимов скорости
#         """
#         return self.speed_modes

# blender = Blender("Bosch", 500, 220, ["Low", "Medium", "High"])
# print(blender.get_info())
# blender.turn_on()
# blender.blend("Medium")




# #№4
# class MeatGrinder(Device):
#     def __init__(self, name, power, voltage, grinding_modes):
#         """
#         Инициализация мясорубки

#         :param name: Название мясорубки
#         :param power: Мощность мясорубки
#         :param voltage: Напряжение мясорубки
#         :param grinding_modes: Режимы измельчения мясорубки
#         """
#         super().__init__(name, power, voltage)
#         self.grinding_modes = grinding_modes

#     def grind(self, grinding_mode):
#         """
#         Измельчение

#         :param grinding_mode: Режим измельчения
#         """
#         if grinding_mode in self.grinding_modes:
#             print(f"Измельчение на режиме {grinding_mode}")
#         else:
#             print("Мясорубка не имеет такого режима измельчения")

#     def get_grinding_modes(self):
#         """
#         Получение списка доступных режимов измельчения

#         :return: Список доступных режимов измельчения
#         """
#         return self.grinding_modes

# meat_grinder = MeatGrinder("Moulinex", 800, 220, ["Fine", "Medium", "Coarse"])
# print(meat_grinder.get_info())
# meat_grinder.turn_on()
# print(meat_grinder.get_grinding_modes())
# meat_grinder.grind("Medium")






# Задание 2
# Создайте класс Ship, который содержит информацию
# о корабле.
# С помощью механизма наследования, реализуйте
# класс Frigate (содержит информацию о фрегате), класс
# Destroyer (содержит информацию об эсминце), класс
# Cruiser (содержит информацию о крейсере).
# Каждый из классов должен содержать необходимые
# для работы методы.






# #№1
# # ship.py
# class Ship:
#     def __init__(self, name, length, width, draft):
#         """
#         Инициализация корабля.

#         :param name: Название корабля
#         :param length: Длина корабля
#         :param width: Ширина корабля
#         :param draft: Осадка корабля
#         """
#         self.name = name
#         self.length = length
#         self.width = width
#         self.draft = draft

#     def get_info(self):
#         """
#         Возвращает информацию о корабле.

#         :return: Строка с информацией о корабле
#         """
#         return f"Корабль '{self.name}': длина - {self.length} м, ширина - {self.width} м, осадка - {self.draft} м"

#     def __str__(self):
#         return self.get_info()
    
# ship = Ship("Корабль", 100, 10, 5)
# print(ship)  # Выводит: Корабль 'Корабль': длина - 100 м, ширина - 10 м, осадка - 5 м







# #№2
# # frigate.py

# class Frigate(Ship):
#     def __init__(self, name, length, width, draft, speed):
#         """
#         Инициализация фрегата.

#         :param name: Название фрегата
#         :param length: Длина фрегата
#         :param width: Ширина фрегата
#         :param draft: Осадка фрегата
#         :param speed: Скорость фрегата
#         """
#         super().__init__(name, length, width, draft)
#         self.speed = speed

#     def get_info(self):
#         """
#         Возвращает информацию о фрегате.

#         :return: Строка с информацией о фрегате
#         """
#         return f"{super().get_info()}, скорость - {self.speed} узлов"

#     def __str__(self):
#         return self.get_info()
    
# frigate = Frigate("Фрегат", 100, 10, 5, 20)
# print(frigate)  # Выводит: Корабль 'Фрегат': длина - 100 м, ширина - 10 м, осадка - 5 м, скорость - 20 узлов
# # destroyer.py







# #№3
# # Destroyer.py

# class Destroyer(Ship):
#     def __init__(self, name, length, width, draft, torpedo_tubes):
#         """
#         Инициализация эсминца.

#         :param name: Название эсминца
#         :param length: Длина эсминца
#         :param width: Ширина эсминца
#         :param draft: Осадка эсминца
#         :param torpedo_tubes: Количество торпедных аппаратов
#         """
#         super().__init__(name, length, width, draft)
#         self.torpedo_tubes = torpedo_tubes

#     def get_info(self):
#         """
#         Возвращает информацию об эсминце.

#         :return: Строка с информацией об эсминце
#         """
#         return f"{super().get_info()}, торпедные аппараты - {self.torpedo_tubes} шт."

#     def __str__(self):
#         return self.get_info()
    
# destroyer = Destroyer("Эсминец", 100, 10, 5, 4)
# print(destroyer)  # Выводит: Корабль 'Эсминец': длина - 100 м, ширина - 10 м, осадка - 5 м, торпедные аппараты - 4 шт.






# #№4
# # cruiser.py

# class Cruiser(Ship):
#     def __init__(self, name, length, width, draft, main_caliber):
#         """
#         Инициализация крейсера.

#         :param name: Название крейсера
#         :param length: Длина крейсера
#         :param width: Ширина крейсера
#         :param draft: Осадка крейсера
#         :param main_caliber: Калибр главной артиллерии
#         """
#         super().__init__(name, length, width, draft)
#         self.main_caliber = main_caliber

#     def get_info(self):
#         """
#         Возвращает информацию о крейсере.

#         :return: Строка с информацией о крейсере
#         """
#         return f"{super().get_info()}, главный калибр - {self.main_caliber}"

# cruiser = Cruiser("Крейсер", 150, 15, 6, "203 мм")
# print(cruiser.get_info())  # Выводит: Корабль 'Крейсер': длина - 150 м, ширина - 15 м, осадка - 6 м, главный калибр - 203 мм





# #№5
# # main.py

# frigate = Frigate("Фрегат", 100, 10, 5, 20)
# destroyer = Destroyer("Эсминец", 120, 12, 6, 4)
# cruiser = Cruiser("Крейсер", 150, 15, 7, 152)

# print(frigate.get_info())
# print(destroyer.get_info())
# print(cruiser.get_info())





## Задание 3
## Запрограммируйте класс Money (объект класса опе-
## рирует одной валютой) для работы с деньгами.
## В классе должны быть предусмотрены поле для хра-
## нения целой части денег (доллары, евро, гривны и т.д.) и
## поле для хранения копеек (центы, евроценты, копейки
## и т.д.).
## Реализовать методы для вывода суммы на экран, за-
## дания значений для частей.





##№1

# class Money:
#     def __init__(self, currency, dollars=0, cents=0):
#         """
#         Инициализация объекта Money.

#         :param currency: Валюта (строка)
#         :param dollars: Целая часть денег (доллары, евро, гривны и т.д.)
#         :param cents: Дробная часть денег (центы, евроценты, копейки и т.д.)
#         """
#         self.currency = currency
#         self.dollars = dollars
#         self.cents = cents

#     def set_dollars(self, dollars):
#         """
#         Установка целой части денег.

#         :param dollars: Целая часть денег
#         """
#         self.dollars = dollars

#     def set_cents(self, cents):
#         """
#         Установка дробной части денег.

#         :param cents: Дробная часть денег
#         """
#         self.cents = cents

#     def get_amount(self):
#         """
#         Возвращает сумму денег в виде строки.

#         :return: Сумма денег в виде строки
#         """
#         return f"{self.dollars}.{self.cents:02} {self.currency}"

#     def __str__(self):
#         return self.get_amount()

# # Пример использования класса Money
# money = Money("USD", 10, 50)
# print(money)  # Выводит: 10.50 USD

# money.set_dollars(20)
# money.set_cents(25)
# print(money)  # Выводит: 20.25 USD







##№2

# class Money:
#     def __init__(self, currency, dollars=0, cents=0):
#         """
#         Инициализация объекта Money.

#         :param currency: Валюта (строка)
#         :param dollars: Целая часть денег (доллары, евро, гривны и т.д.)
#         :param cents: Дробная часть денег (центы, евроценты, копейки и т.д.)
#         """
#         self.currency = currency
#         self.dollars = dollars
#         self.cents = cents

#     def set_dollars(self, dollars):
#         """
#         Установка целой части денег.

#         :param dollars: Целая часть денег
#         """
#         self.dollars = dollars

#     def set_cents(self, cents):
#         """
#         Установка дробной части денег.

#         :param cents: Дробная часть денег
#         """
#         self.cents = cents

#     def get_amount(self):
#         """
#         Возвращает сумму денег в виде строки.

#         :return: Сумма денег в виде строки
#         """
#         return f"{self.dollars}.{self.cents:02} {self.currency}"

#     def __str__(self):
#         return self.get_amount()

# def main():
#     print("Добро пожаловать в меню Money!")
#     currency = input("Введите валюту (например, USD, EUR, UAH): ")
#     money = Money(currency)

#     while True:
#         print("\nМеню:")
#         print("1. Установить сумму денег")
#         print("2. Вывести сумму денег")
#         print("3. Выход")

#         choice = input("Введите номер пункта меню: ")

#         if choice == "1":
#             dollars = int(input("Введите целую часть денег: "))
#             cents = int(input("Введите дробную часть денег: "))
#             money.set_dollars(dollars)
#             money.set_cents(cents)
#         elif choice == "2":
#             print(money)
#         elif choice == "3":
#             print("До свидания!")
#             break
#         else:
#             print("Неверный номер пункта меню. Пожалуйста, попробуйте еще раз.")

# if __name__ == "__main__":
#     main()






## №3

# class Money:
#     def __init__(self, currency, dollars=0, cents=0):
#         """
#         Инициализация объекта Money.

#         :param currency: Валюта (строка)
#         :param dollars: Целая часть денег (доллары, евро, гривны и т.д.)
#         :param cents: Дробная часть денег (центы, евроценты, копейки и т.д.)
#         """
#         self.currency = currency
#         self.dollars = dollars
#         self.cents = cents

#     def set_dollars(self, dollars):
#         """
#         Установка целой части денег.

#         :param dollars: Целая часть денег
#         """
#         self.dollars = dollars

#     def set_cents(self, cents):
#         """
#         Установка дробной части денег.

#         :param cents: Дробная часть денег
#         """
#         self.cents = cents

#     def get_amount(self):
#         """
#         Возвращает сумму денег в виде строки.

#         :return: Сумма денег в виде строки
#         """
#         return f"{self.dollars}.{self.cents:02} {self.currency}"

#     def __str__(self):
#         return self.get_amount()

# class Bank:
#     def __init__(self):
#         self.exchange_rates = {
#             "USD": 1.0,
#             "EUR": 0.88,
#             "UAH": 26.5
#         }
#         self.interest_rates = {
#             "USD": 0.05,
#             "EUR": 0.03,
#             "UAH": 0.10
#         }

#     def convert(self, money, new_currency):
#         """
#         Переводит деньги из одной валюты в другую.

#         :param money: Объект Money
#         :param new_currency: Новая валюта
#         :return: Объект Money с новой валютой
#         """
#         new_amount = money.dollars * self.exchange_rates[money.currency] / self.exchange_rates[new_currency]
#         return Money(new_currency, int(new_amount), int((new_amount - int(new_amount)) * 100))

#     def deposit(self, money, years):
#         """
#         Положить деньги под процент.

#         :param money: Объект Money
#         :param years: Количество лет
#         :return: Объект Money с новой суммой
#         """
#         interest_rate = self.interest_rates[money.currency]
#         new_amount = money.dollars * (1 + interest_rate) ** years
#         return Money(money.currency, int(new_amount), int((new_amount - int(new_amount)) * 100))

# def main():
#     print("Добро пожаловать в меню Money!")
#     bank = Bank()
#     currency = input("Введите валюту (например, USD, EUR, UAH): ")
#     money = Money(currency)

#     while True:
#         print("\nМеню:")
#         print("1. Установить сумму денег")
#         print("2. Вывести сумму денег")
#         print("3. Перевести деньги в другую валюту")
#         print("4. Положить деньги под процент")
#         print("5. Выход")

#         choice = input("Введите номер пункта меню: ")

#         if choice == "1":
#             dollars = int(input("Введите целую часть денег: "))
#             cents = int(input("Введите дробную часть денег: "))
#             money.set_dollars(dollars)
#             money.set_cents(cents)
#         elif choice == "2":
#             print(money)
#         elif choice == "3":
#             new_currency = input("Введите новую валюту (например, USD, EUR, UAH): ")
#             new_money = bank.convert(money, new_currency)
#             print(new_money)
#         elif choice == "4":
#             years = int(input("Введите количество лет: "))
#             new_money = bank.deposit(money, years)
#             print(new_money)
#         elif choice == "5":
#             print("До свидания!")
#             break
#         else:
#             print("Неверный номер пункта меню. Пожалуйста, попробуйте еще раз.")

# if __name__ == "__main__":
#     main()





## Модуль 10.Обьектно-ориентированное программирование 
## Тема:Перезагрузка операторов.Часть 5







# [Обозночение]

# Комплексное число - это математическое понятие, которое расширяет понятие обычного числа, добавляя к нему.imaginary часть. Комплексное число обычно записывается в виде:

# a + bi

# где:

# a - real part (действительная часть)
# b - imaginary part (мнимая часть)
# i - imaginary unit (мнимая единица), которая равна квадратному корню из -1 (i = √(-1))

# Комплексные числа используются в различных областях математики и физики, таких как алгебра, геометрия, анализ, электротехника, физика и другие.

# В частности, комплексные числа полезны для решения уравнений, которые не имеют решений в области вещественных чисел. Например, уравнение x^2 + 1 = 0 не имеет решений в области вещественных чисел, но имеет два комплексных решения: x = i и x = -i.

# Комплексные числа также используются для описания периодических процессов, таких как колебания и волны, а также для моделирования электрических цепей и других физических систем.                                                                            







## Задание 1
## Создайте класс Circle (окружность). Для данного
## класса реализуйте ряд перегруженных операторов:
## ■ Проверка на равенство радиусов двух окружностей
## (операция = =);
## ■ Сравнения длин двух окружностей (операции >, <,
## <=,>=);
## ■ Пропорциональное изменение размеров окружности,
## путем изменения ее радиуса (операции + - += -=).





# class Circle:
#     def __init__(self, radius):
#         self.radius = radius

#     def __eq__(self, other):
#         return self.radius == other.radius

#     def __lt__(self, other):
#         return self.radius < other.radius

#     def __le__(self, other):
#         return self.radius <= other.radius

#     def __gt__(self, other):
#         return self.radius > other.radius

#     def __ge__(self, other):
#         return self.radius >= other.radius

#     def __add__(self, other):
#         return Circle(self.radius + other.radius)

#     def __sub__(self, other):
#         return Circle(self.radius - other.radius)

#     def __iadd__(self, other):
#         self.radius += other.radius
#         return self




## Это определение класса Python для класса Circle. Вот описание того, что происходит:

## Инициализация

## Метод __init__ является конструктором класса. Он принимает единственный аргумент radius и устанавливает его в качестве переменной экземпляра self.radius.

## Методы сравнения

## В классе определено несколько методов сравнения:

## __eq__: проверяет, равны ли две окружности (т. е. имеют ли они одинаковый радиус).
## __lt__: проверяет, меньше ли одна окружность другой (т. е. имеет ли она меньший радиус)
## __le__: проверяет, меньше или равна ли одна окружность другой
## __gt__: проверяет, больше ли одна окружность другой
## __ge__: проверяет, больше или равна ли одна окружность другой.
## Эти методы позволяют сравнивать объекты Circle с помощью стандартных операторов сравнения (==, <, <=, >, >=).

## Арифметические методы

## В классе определены два арифметических метода:

## __add__: складывает две окружности путем сложения их радиусов и возвращает новый объект Circle с полученным радиусом.
## __sub__: вычитает одну окружность из другой путем вычитания их радиусов и возвращает новый объект Circle с полученным радиусом
## __iadd__: увеличивает радиус текущей окружности путем добавления радиуса другой окружности (сложение на месте).
## Эти методы позволяют выполнять арифметические операции над объектами Circle с помощью стандартных операторов (+, -, +=).

## Примечание

## Отступы в исходном коде сделаны неправильно. Методы должны быть определены на уровне класса, а не внутри метода __init__. Вот исправленный код:






## Задание 2
## Создайте класс Complex (комплексное число). Более
## подробно ознакомиться с комплексными числами можно
## по ссылке.
## Создайте перегруженные операторы для реализации
## арифметических операций для по работе с комплексными
## числами (операции +, -, *, /).






# class Complex:
#     def __init__(self, real=0, imag=0):
#         self.real = real
#         self.imag = imag

#     def __add__(self, other):
#         return Complex(self.real + other.real, self.imag + other.imag)

#     def __sub__(self, other):
#         return Complex(self.real - other.real, self.imag - other.imag)

#     def __mul__(self, other):
#         return Complex(self.real * other.real - self.imag * other.imag, self.real * other.imag + self.imag * other.real)

#     def __truediv__(self, other):
#         denominator = other.real ** 2 + other.imag ** 2
#         return Complex((self.real * other.real + self.imag * other.imag) / denominator,
#                         (self.imag * other.real - self.real * other.imag) / denominator)

#     def __str__(self):
#         return f"{self.real} + {self.imag}i"

# c1 = Complex(3, 4)  # represents 3 + 4i
# c2 = Complex(1, 2)  # represents 1 + 2i

# c3 = c1 + c2  # c3 = Complex(4, 6)  # represents 4 + 6i
# c4 = c1 - c2  # c4 = Complex(2, 2)  # represents 2 + 2i
# c5 = c1 * c2  # c5 = Complex(-5, 10)  # represents -5 + 10i
# c6 = c1 / c2  # c6 = Complex(2.2, -0.4)  # represents 2.2 - 0.4i

# print(c1)  # Output: 3 + 4i
# print(c2)  # Output: 1 + 2i
# print(c3)  # Output: 4 + 6i
# print(c4)  # Output: 2 + 2i
# print(c5)  # Output: -5 + 10i
# print(c6)  # Output: 2.2 - 0.4i








## c1 = 3 + 4i, где a = 3, b = 4
## c2 = 1 + 2i, где a = 1, b = 2
## c3 = 4 + 6i, где a = 4, b = 6
## c4 = 2 + 2i, где a = 2, b = 2
## c5 = -5 + 10i, где a = -5, b = 10
## c6 = 2.2 - 0.4i, где a = 2.2, b = -0.4




## Определение класса

## В коде определен класс Complex, который представляет комплексные числа. Комплексное число - это число, которое можно выразить в виде a + bi, где a - действительная часть, а b - мнимая часть.

## Метод __init__

## Метод __init__ - это специальный метод в Python, который вызывается при создании объекта. В данном случае он инициализирует объект Complex с двумя атрибутами: real и imag.
# Эти атрибуты представляют действительную и мнимую части комплексного числа, соответственно. Метод __init__ принимает два необязательных аргумента, real и imag, которые по умолчанию равны 0, если не указаны.

## Метод __add__

## Метод __add__ - это специальный метод в Python, который вызывается при использовании оператора +. В данном случае он складывает два комплексных числа.
#  В качестве аргумента метод принимает другой объект Complex, other. Он возвращает новый объект Complex, который представляет собой сумму двух комплексных чисел.

## Вот что происходит при вызове метода c1 + c2:

## c1 и c2 - оба комплексные объекты.
## Метод __add__ вызывается на c1 с c2 в качестве аргумента.
## Метод возвращает новый объект Complex с вещественной частью c1.real + c2.real и образной частью c1.imag + c2.imag.
## Метод __sub__

## Метод __sub__ похож на метод __add__, но вместо сложения он вычитает два комплексных числа.

## Метод __mul__

## Метод __mul__ перемножает два комплексных числа. Он возвращает новый объект Complex с вещественной частью c1.real * c2.real - c1.imag * c2.imag и вещественной частью c1.real * c2.imag + c1.imag * c2.real.

## Метод __truediv__

## Метод __truediv__ делит два комплексных числа. Он возвращает новый объект Complex с вещественной частью (c1.real * c2.real + c1.imag * c2.imag) / знаменатель и вещественной частью (c1.imag * c2.real - c1.real * c2.imag) / знаменатель, где знаменатель равен c2.real ** 2 + c2.imag ** 2.

## Метод __str__

## Метод __str__ возвращает строковое представление комплексного числа. В данном случае он возвращает строку в виде a + bi, где a - действительная часть, а b - мнимая часть.

## Создание комплексных объектов

## Код создает шесть комплексных объектов: c1, c2, c3, c4, c5 и c6.

## c1 представляет комплексное число 3 + 4i.
## c2 представляет комплексное число 1 + 2i.
## c3 представляет собой сумму c1 и c2, которая равна 4 + 6i.
## c4 представляет собой разность c1 и c2, которая равна 2 + 2i.
## c5 представляет собой произведение c1 и c2, которое равно -5 + 10i.
## c6 представляет собой коэффициент c1 и c2, который равен 2,2 - 0,4i.
## Печать сложных объектов

## Код печатает каждый сложный объект с помощью функции print. Для преобразования каждого сложного объекта в строку неявно вызывается метод __str__.







## Задание 3
## Вам необходимо создать класс Airplane (самолет).
## С помощью перегрузги операторов реализовать:
## ■ Проверка на равенство типов самолетов (операция
## = =);
## ■ Увеличение и уменьшение пассажиров в салоне са-
## молета (операции + - += -=);
## ■ Сравнение двух самолетов по максимально возмож-
## ному количеству пассажиров на борту (операции >
## < <= >=).


# class Airplane:
#     def __init__(self, max_passengers):
#         self.max_passengers = max_passengers
#         self.passengers = 0

#     def __eq__(self, other):
#         return self.max_passengers == other.max_passengers

#     def __add__(self, other):
#         if isinstance(other, Airplane):
#             if self.max_passengers >= other.passengers:
#                 self.passengers += other.passengers
#                 return self
#             else:
#                 return "Error: самолет не может вместить всех пассажиров"
#         elif isinstance(other, int):
#             if self.passengers + other <= self.max_passengers:
#                 self.passengers += other
#                 return self
#             else:
#                 return "Error: превышен лимит пассажиров"
#         else:
#             return "Error: неверный тип операнда"

#     def __sub__(self, other):
#         if isinstance(other, Airplane):
#             if self.passengers >= other.passengers:
#                 self.passengers -= other.passengers
#                 return self
#             else:
#                 return "Error: недостаточно пассажиров для удаления"
#         elif isinstance(other, int):
#             if self.passengers >= other:
#                 self.passengers -= other
#                 return self
#             else:
#                 return "Error: недостаточно пассажиров для удаления"
#         else:
#             return "Error: неверный тип операнда"

#     def __iadd__(self, other):
#         return self.__add__(other)

#     def __isub__(self, other):
#         return self.__sub__(other)

#     def __gt__(self, other):
#         return self.max_passengers > other.max_passengers

#     def __lt__(self, other):
#         return self.max_passengers < other.max_passengers

#     def __ge__(self, other):
#         return self.max_passengers >= other.max_passengers

#     def __le__(self, other):
#         return self.max_passengers <= other.max_passengers

#     def __str__(self):
#         return f"Airplane(max_passengers={self.max_passengers}, passengers={self.passengers})"
    
# plane1 = Airplane(100)
# plane2 = Airplane(50)

# print(plane1 == plane2)  # False

# plane1 + 20  # добавляем 20 пассажиров
# print(plane1)  # Airplane(max_passengers=100, passengers=20)

# plane1 - 10  # удаляем 10 пассажиров
# print(plane1)  # Airplane(max_passengers=100, passengers=10)

# print(plane1 > plane2)  # True
# print(plane1 < plane2)  # False          






## Определение класса

## В коде определен класс под названием Airplane. У этого класса есть несколько методов, которые позволяют нам выполнять операции над объектами этого класса.

## Метод __init__

## Метод __init__ - это специальный метод в Python, который вызывается при создании объекта. Он инициализирует атрибуты объекта.
#  В данном случае метод __init__ принимает один аргумент max_passengers, который является максимальным количеством пассажиров, которое может вместить самолет. Он также инициализирует атрибут passengers значением 0 - это текущее количество пассажиров в самолете.

## Метод __eq__

## Метод __eq__ - это специальный метод в Python, который вызывается при использовании оператора ==. Он проверяет, равны ли два объекта. В данном случае метод __eq__ проверяет, равен ли атрибут max_passengers у двух объектов Airplane.

## Метод __add__

## Метод __add__ - это специальный метод в Python, который вызывается при использовании оператора +. Он складывает два объекта вместе. В данном случае метод __add__ может принимать два типа аргументов:

## Другой объект Airplane: Проверяется, может ли текущий самолет вместить всех пассажиров из другого самолета. Если может, то он добавляет пассажиров из другого самолета в текущий самолет. Если нет, то возвращается сообщение об ошибке.
## Integer: Проверяет, не превысит ли добавление целого числа к текущему количеству пассажиров максимальную вместимость самолета. Если нет, то добавляет целое число к текущему числу пассажиров. Если да, то возвращается сообщение об ошибке.
## Метод __sub__

## Метод __sub__ похож на метод __add__, но он вычитает, а не прибавляет. Он также может принимать два типа аргументов:

## Другой объект Airplane: Проверяется, достаточно ли пассажиров в текущем самолете, чтобы удалить всех пассажиров из другого самолета. Если да, то он удаляет пассажиров из другого самолета из текущего самолета. Если нет, то возвращается сообщение об ошибке.
## Целое число: Проверяет, не приведет ли вычитание целого числа из текущего количества пассажиров к отрицательному числу. Если нет, то вычитает целое число из текущего количества пассажиров. Если да, то возвращается сообщение об ошибке.
## Методы __iadd__ и __isub__

## Эти методы похожи на методы __add__ и __sub__, но они изменяют объект на месте, а не возвращают новый объект.

## Методы сравнения

## Методы __gt__, __lt__, __ge__ и __le__ - это специальные методы в Python, которые вызываются при использовании операторов сравнения (например, >, <, >=, <=). Они сравнивают атрибут max_passengers двух объектов Airplane.

## Метод __str__

## Метод __str__ - это специальный метод в Python, который вызывается при использовании функции str(). Он возвращает строковое представление объекта.

## Пример использования

## Код создает два объекта Airplane, plane1 и plane2, с максимальной вместимостью 100 и 50 пассажиров соответственно.

## Затем он проверяет, равен ли самолет1 самолету2, используя оператор ==, который вызывает метод __eq__. Поскольку максимальные вместимости разные, он возвращает False.

## Затем он добавляет 20 пассажиров к самолету1 с помощью оператора +, который вызывает метод __add__. Поскольку текущее количество пассажиров (0) плюс 20 меньше или равно максимальной вместимости (100), он добавляет 20 пассажиров в самолет1.

## Затем он вычитает 10 пассажиров из самолета1 с помощью оператора -, который вызывает метод __sub__. Поскольку текущее количество пассажиров (20) минус 10 больше или равно 0, он вычитает 10 пассажиров из самолета1.

## Наконец, он сравнивает самолет1 и самолет2 с помощью операторов > и <, которые вызывают методы __gt__ и __lt__ соответственно. Поскольку максимальная вместимость самолета1 больше, чем у самолета2, он возвращает True для оператора > и False для оператора <.





## Задание 4
## Создать класс Flat (квартира). Реализовать перегру-
## женные операторы:
## ■ Проверка на равенство площадей квартир (операция
## ==);
## ■ Проверка на неравенство площадей квартир (опера-
## ция !=);
## ■ Сравнение двух квартир по цене (операции > < <= >=).





# class Flat:
#     def __init__(self, area, price):
#         self.area = area
#         self.price = price

#     def __eq__(self, other):
#         if not isinstance(other, Flat):
#             raise TypeError("Нельзя сравнивать с объектом другого класса")
#         return self.area == other.area

#     def __ne__(self, other):
#         if not isinstance(other, Flat):
#             raise TypeError("Нельзя сравнивать с объектом другого класса")
#         return self.area != other.area

#     def __gt__(self, other):
#         if not isinstance(other, Flat):
#             raise TypeError("Нельзя сравнивать с объектом другого класса")
#         return self.price > other.price

#     def __lt__(self, other):
#         if not isinstance(other, Flat):
#             raise TypeError("Нельзя сравнивать с объектом другого класса")
#         return self.price < other.price

#     def __ge__(self, other):
#         if not isinstance(other, Flat):
#             raise TypeError("Нельзя сравнивать с объектом другого класса")
#         return self.price >= other.price

#     def __le__(self, other):
#         if not isinstance(other, Flat):
#             raise TypeError("Нельзя сравнивать с объектом другого класса")
#         return self.price <= other.price

#     def __str__(self):
#         return f"Flat(area={self.area}, price={self.price})"

# flat1 = Flat(100, 1000)
# flat2 = Flat(100, 2000)
# print(flat1)  # Flat(area=100, price=1000)
# print(flat2)  # Flat(area=100, price=2000)
# print(flat1 == flat2)  # True
# print(flat1 != flat2)  # False
# print(flat1 > flat2)  # False
# print(flat1 < flat2)  # True







## Определение класса

## В коде определен класс Flat со следующими атрибутами:

## площадь: целое число, представляющее площадь квартиры
## цена: целое число, представляющее цену квартиры.
## Класс имеет несколько специальных методов (также известных как «магические методы» или «методы Дандера»), которые используются для переопределения поведения по умолчанию встроенных операторов Python.

## Метод __init__

## Метод __init__ - это специальный метод, который вызывается при создании объекта. Он инициализирует атрибуты объекта заданными значениями. В данном случае он устанавливает атрибуты area и price объекта Flat.

## Методы __eq__ и __ne__

## Метод __eq__ используется для переопределения оператора ==, который проверяет равенство между двумя объектами. В данном случае он проверяет, равен ли атрибут area двух объектов Flat.

## Метод __ne__ используется для переопределения оператора !=, который проверяет неравенство между двумя объектами. Он просто возвращает значение, противоположное методу __eq__.

## Методы __gt__, __lt__, __ge__ и __le__

## Эти методы используются для переопределения операторов сравнения:

## __gt__: Оператор >, проверяет, больше ли атрибут цены текущего объекта, чем атрибут цены другого объекта.
## __lt__: < оператор, проверяет, меньше ли атрибут цены текущего объекта, чем атрибут цены другого объекта.
## __ge__: >= оператор, проверяет, больше или равен ли атрибут цены текущего объекта атрибуту цены другого объекта.
## __le__: <= оператор, проверяет, меньше или равен ли атрибут цены текущего объекта атрибуту цены другого объекта.
## Метод __str__

## Метод __str__ используется для переопределения функции str(), которая возвращает строковое представление объекта. В данном случае возвращается строка в формате Flat(area=<area>, price=<price>).

## Создание и сравнение объектов

## Код создает два объекта Flat, flat1 и flat2, с разными ценами, но одинаковой площадью.

## Затем код печатает строковое представление каждого объекта с помощью функции print().

## Наконец, код сравнивает два объекта с помощью переопределенных операторов сравнения:

## flat1 == flat2 проверяет, равны ли атрибуты площади, что является истиной.
## flat1 != flat2 проверяет, не равны ли атрибуты области, что является False.
## flat1 > flat2 проверяет, что атрибут цены flat1 больше атрибута цены flat2, что является Ложью.
## flat1 < flat2 проверяет, что ценовой атрибут flat1 меньше ценового атрибута flat2, что является Истиной.







## Модуль 10 Объектно-ориентированное
## программирование
## Тема: Классы. Объекты. Часть 1






##  Задание 1
##  Реализуйте класс «Автомобиль». Необходимо хранить
##  в полях класса: название модели, год выпуска, произво-
##  дителя, объем двигателя, цвет машины, цену. Реализуйте
##  методы класса для ввода данных, вывода данных, реа-
##  лизуйте доступ к отдельным полям через методы класса.







# class Car:
#     def __init__(self, model=None, year=None, manufacturer=None, engine_volume=None, color=None, price=None):
#         self.model = model
#         self.year = year
#         self.manufacturer = manufacturer
#         self.engine_volume = engine_volume
#         self.color = color
#         self.price = price

#     def input_data(self):
#         self.model = input("Введите модель: ")
#         self.year = int(input("Введите год выпуска: "))
#         self.manufacturer = input("Введите производителя: ")
#         self.engine_volume = float(input("Введите объем двигателя: "))
#         self.color = input("Введите цвет: ")
#         self.price = float(input("Введите цену: "))

#     def output_data(self):
#         print(f"Модель: {self.model}")
#         print(f"Год выпуска: {self.year}")
#         print(f"Производитель: {self.manufacturer}")
#         print(f"Объем двигателя: {self.engine_volume}")
#         print(f"Цвет: {self.color}")
#         print(f"Цена: {self.price}")

#     def get_model(self):
#         return self.model

#     def get_year(self):
#         return self.year

#     def get_manufacturer(self):
#         return self.manufacturer

#     def get_engine_volume(self):
#         return self.engine_volume

#     def get_color(self):
#         return self.color

#     def get_price(self):
#         return self.price

# # Создаем объект Car и вводим данные
# my_car = Car()
# my_car.input_data()
# my_car.output_data()
# print(my_car.get_model())







# # Задание 2
# Реализуйте класс «Книга». Необходимо хранить в
# полях класса: название книги, год выпуска, издателя,
# жанр, автора, цену. Реализуйте методы класса для ввода
# данных, вывода данных, реализуйте доступ к отдельным
# полям через методы класса.






# class Book:
#     def __init__(self, title=None, year=None, publisher=None, genre=None, author=None, price=None):
#         self.title = title
#         self.year = year
#         self.publisher = publisher
#         self.genre = genre
#         self.author = author
#         self.price = price

#     def input_data(self):
#         self.title = input("Введите название книги: ")
#         self.year = int(input("Введите год выпуска: "))
#         self.publisher = input("Введите издателя: ")
#         self.genre = input("Введите жанр: ")
#         self.author = input("Введите автора: ")
#         self.price = float(input("Введите цену: "))

#     def output_data(self):
#         print(f"Название книги: {self.title}")
#         print(f"Год выпуска: {self.year}")
#         print(f"Издатель: {self.publisher}")
#         print(f"Жанр: {self.genre}")
#         print(f"Автор: {self.author}")
#         print(f"Цена: {self.price}")

#     def get_title(self):
#         return self.title

#     def get_year(self):
#         return self.year

#     def get_publisher(self):
#         return self.publisher

#     def get_genre(self):
#         return self.genre

#     def get_author(self):
#         return self.author

#     def get_price(self):
#         return self.price

# # Создаем объект Book и вводим данные
# my_book = Book()
# my_book.input_data()
# my_book.output_data()
# print(my_book.get_title())







# Задание 3
# Реализуйте класс «Стадион». Необходимо хранить в
# полях класса: название стадиона, дату открытия, страну,
# город, вместимость. Реализуйте методы класса для ввода
# данных, вывода данных, реализуйте доступ к отдельным
# полям через методы класса.





# class Stadium:
#     def __init__(self, name=None, opening_date=None, country=None, city=None, capacity=None):
#         self.name = name
#         self.opening_date = opening_date
#         self.country = country
#         self.city = city
#         self.capacity = capacity

#     def input_data(self):
#         self.name = input("Введите название стадиона: ")
#         self.opening_date = input("Введите дату открытия (в формате дд.мм.гггг): ")
#         self.country = input("Введите страну: ")
#         self.city = input("Введите город: ")
#         self.capacity = int(input("Введите вместимость: "))

#     def output_data(self):
#         print(f"Название стадиона: {self.name}")
#         print(f"Дата открытия: {self.opening_date}")
#         print(f"Страна: {self.country}")
#         print(f"Город: {self.city}")
#         print(f"Вместимость: {self.capacity}")

#     def get_name(self):
#         return self.name

#     def get_opening_date(self):
#         return self.opening_date

#     def get_country(self):
#         return self.country

#     def get_city(self):
#         return self.city

#     def get_capacity(self):
#         return self.capacity

# # Создаем объект Stadium и вводим данные
# my_stadium = Stadium()
# my_stadium.input_data()
# my_stadium.output_data()
# print(my_stadium.get_name())





## Модуль 10 Объектно-ориентированное
## программирование
## Тема: Классы. Объекты. Конструкторы.
## Перегрузка методов. Часть 2





# Задание 1
# К уже реализованному классу «Автомобиль» добавьте
# конструктор, а также необходимые перегруженные методы.


# class Car:
#     def __init__(self, model=None, year=None, manufacturer=None, engine_volume=None, color=None, price=None):
#         self.model = model
#         self.year = year
#         self.manufacturer = manufacturer
#         self.engine_volume = engine_volume
#         self.color = color
#         self.price = price

#     def __str__(self):
#         return f"Модель: {self.model}, Год выпуска: {self.year}, Производитель: {self.manufacturer}, Объем двигателя: {self.engine_volume}, Цвет: {self.color}, Цена: {self.price}"

#     def __repr__(self):
#         return f"Car('{self.model}', {self.year}, '{self.manufacturer}', {self.engine_volume}, '{self.color}', {self.price})"

#     def __eq__(self, other):
#         return self.model == other.model and self.year == other.year and self.manufacturer == other.manufacturer

#     def input_data(self):
#         self.model = input("Введите модель: ")
#         self.year = int(input("Введите год выпуска: "))
#         self.manufacturer = input("Введите производителя: ")
#         self.engine_volume = float(input("Введите объем двигателя: "))
#         self.color = input("Введите цвет: ")
#         self.price = float(input("Введите цену: "))

#     def output_data(self):
#         print(f"Модель: {self.model}")
#         print(f"Год выпуска: {self.year}")
#         print(f"Производитель: {self.manufacturer}")
#         print(f"Объем двигателя: {self.engine_volume}")
#         print(f"Цвет: {self.color}")
#         print(f"Цена: {self.price}")

#     def get_model(self):
#         return self.model

#     def get_year(self):
#         return self.year

#     def get_manufacturer(self):
#         return self.manufacturer

#     def get_engine_volume(self):
#         return self.engine_volume

#     def get_color(self):
#         return self.color

#     def get_price(self):
#         return self.price

# # Создаем объект Car и вводим данные
# my_car = Car()
# my_car.input_data()
# print(my_car)  # Используем перегруженный метод __str__
# print(repr(my_car))  # Используем перегруженный метод __repr__

# # Создаем другой объект Car
# my_car2 = Car("Toyota", 2020, "Toyota Motor Corporation", 2.0, "Silver", 25000)
# print(my_car2)

# # Сравниваем два объекта Car
# print(my_car == my_car2)  # Используем перегруженный метод __eq__








## Вот подробное объяснение кода:

## Определение класса

## Код определяет класс под названием Car с несколькими методами и атрибутами.

## Атрибуты

## Класс имеет шесть атрибутов:

## модель: модель автомобиля
## год: год выпуска автомобиля
## производитель: производитель автомобиля
## engine_volume: объем двигателя автомобиля
## цвет: цвет автомобиля
## цена: цена автомобиля
## Метод __init__

## Метод __init__ - это специальный метод в Python, который вызывается при создании объекта. Он инициализирует атрибуты объекта переданными ему значениями. В данном случае метод __init__ принимает шесть аргументов: model, year, manufacturer, engine_volume, color и price. 
# Эти аргументы присваиваются соответствующим атрибутам объекта.

## Метод __str__

## Метод __str__ - это еще один специальный метод в Python, который возвращает строковое представление объекта. В данном случае метод __str__ возвращает строку, содержащую значения всех атрибутов, отформатированную в удобном для чтения виде. 
# Этот метод используется для создания человекочитаемого представления объекта.

## Метод __repr__

## Метод __repr__ похож на метод __str__, но он возвращает строку, представляющую объект таким образом, что ее можно использовать для воссоздания объекта. 
# В данном случае метод __repr__ возвращает строку, включающую значения всех атрибутов, оформленную в виде выражения Python, которое можно использовать для создания нового объекта Car. Этот метод используется для создания машиночитаемого представления объекта.

## Метод __eq__

## Метод __eq__ - это специальный метод в Python, который вызывается, когда оператор == используется для сравнения двух объектов. В этом случае метод __eq__ возвращает True, если атрибуты модели, года и производителя двух объектов одинаковы, и False в противном случае.
#  Этот метод используется для сравнения двух объектов Car на равенство.

## Метод input_data

## Метод input_data - это обычный метод, который предлагает пользователю ввести данные для атрибутов автомобиля и присваивает введенные значения соответствующим атрибутам.

## Метод output_data

## Метод output_data - это обычный метод, который распечатывает значения всех атрибутов в удобном для чтения формате.

## Геттерные методы

## Класс имеет шесть геттерных методов: get_model, get_year, get_manufacturer, get_engine_volume, get_color и get_price. Эти методы просто возвращают значения соответствующих атрибутов.

## Создание объектов и использование методов

## Код создает два объекта Car: my_car и my_car2. Метод input_data используется для ввода данных для my_car, а функция print - для вывода значений всех атрибутов с помощью метода __str__. Функция repr используется для вывода представления объекта с помощью метода __repr__.

## Объект my_car2 создается с заранее заданными значениями атрибутов, а функция print используется для вывода значений всех атрибутов с помощью метода __str__.

## Наконец, код сравнивает два объекта с помощью оператора ==, который вызывает метод __eq__. Результат сравнения выводится на печать.

## Ниже приводится пошаговое описание того, что происходит при выполнении кода:

## Определяется класс Car с его атрибутами и методами.
## Создается объект my_car без начальных значений.
## У my_car вызывается метод input_data, предлагающий пользователю ввести данные для атрибутов автомобиля.
## Пользователь вводит данные для атрибутов автомобиля, и полученные значения присваиваются соответствующим атрибутам my_car.
## Функция print используется для вывода значений всех атрибутов my_car с помощью метода __str__.
## Функция repr используется для вывода представления my_car с помощью метода __repr__.
## Объект my_car2 создается с заранее заданными значениями его атрибутов.
## Функция print используется для вывода значений всех атрибутов my_car2 с помощью метода __str__.
## Для сравнения my_car и my_car2 используется оператор ==, который вызывает метод __eq__.
## Результат сравнения выводится на печать.











# Задание 2
# К уже реализованному классу «Книга» добавьте кон-
# структор, а также необходимые перегруженные методы.






# class Book:
#     def __init__(self, title=None, author=None, year=None, publisher=None, pages=None, price=None):
#         self.title = title
#         self.author = author
#         self.year = year
#         self.publisher = publisher
#         self.pages = pages
#         self.price = price

#     def __str__(self):
#         return f"Название: {self.title}, Автор: {self.author}, Год издания: {self.year}, Издательство: {self.publisher}, Количество страниц: {self.pages}, Цена: {self.price}"

#     def __repr__(self):
#         return f"Book('{self.title}', '{self.author}', {self.year}, '{self.publisher}', {self.pages}, {self.price})"

#     def __eq__(self, other):
#         return self.title == other.title and self.author == other.author and self.year == other.year

#     def input_data(self):
#         self.title = input("Введите название книги: ")
#         self.author = input("Введите автора: ")
#         self.year = int(input("Введите год издания: "))
#         self.publisher = input("Введите издательство: ")
#         self.pages = int(input("Введите количество страниц: "))
#         self.price = float(input("Введите цену: "))

#     def output_data(self):
#         print(f"Название: {self.title}")
#         print(f"Автор: {self.author}")
#         print(f"Год издания: {self.year}")
#         print(f"Издательство: {self.publisher}")
#         print(f"Количество страниц: {self.pages}")
#         print(f"Цена: {self.price}")

#     def get_title(self):
#         return self.title

#     def get_author(self):
#         return self.author

#     def get_year(self):
#         return self.year

#     def get_publisher(self):
#         return self.publisher

#     def get_pages(self):
#         return self.pages

#     def get_price(self):
#         return self.price

# # Создаем объект Book и вводим данные
# my_book = Book()
# my_book.input_data()
# print(my_book)  # Используем перегруженный метод __str__
# print(repr(my_book))  # Используем перегруженный метод __repr__

# # Создаем другой объект Book
# my_book2 = Book("Python для начинающих", "Джон Смит", 2020, "ООО 'Издательство'", 300, 1500)
# print(my_book2)

# # Сравниваем два объекта Book
# print(my_book == my_book2)  # Используем перегруженный метод __eq__








## Вот подробное объяснение кода:

## Определение класса

## Код определяет класс под названием Book с несколькими методами и атрибутами.

## Атрибуты

## Класс имеет шесть атрибутов:

## title: название книги
## author: автор книги
## год: год публикации книги
## издатель: издатель книги
## страницы: количество страниц в книге
## цена: цена книги
## Метод __init__

## Метод __init__ - это специальный метод в Python, который вызывается при создании объекта. Он инициализирует атрибуты объекта переданными ему значениями. 
# В данном случае метод __init__ принимает шесть аргументов: название, автор, год, издательство, страницы и цена. Эти аргументы присваиваются соответствующим атрибутам объекта.

## Метод __str__

## Метод __str__ - это еще один специальный метод в Python, который возвращает строковое представление объекта.
#  В данном случае метод __str__ возвращает строку, содержащую значения всех атрибутов, отформатированную в удобном для чтения виде. Этот метод используется для создания человекочитаемого представления объекта.

## Метод __repr__

## Метод __repr__ похож на метод __str__, но он возвращает строку, представляющую объект таким образом, что ее можно использовать для воссоздания объекта. 
# В данном случае метод __repr__ возвращает строку, содержащую значения всех атрибутов, оформленную в виде выражения Python, которое можно использовать для создания нового объекта Book. Этот метод используется для создания машиночитаемого представления объекта.

## Метод __eq__

## Метод __eq__ - это специальный метод в Python, который вызывается, когда оператор == используется для сравнения двух объектов.
#  В этом случае метод __eq__ возвращает True, если атрибуты title, author и year двух объектов равны, и False в противном случае. Этот метод используется для сравнения двух объектов Book на равенство.

## Метод input_data

## Метод input_data - это обычный метод, который предлагает пользователю ввести данные для атрибутов книги и присваивает введенные значения соответствующим атрибутам.

## Метод output_data

## Метод output_data - это обычный метод, который распечатывает значения всех атрибутов в удобном для чтения формате.

## Геттерные методы

## Класс имеет шесть геттерных методов: get_title, get_author, get_year, get_publisher, get_pages и get_price. Эти методы просто возвращают значения соответствующих атрибутов.

## Создание объектов и использование методов

## Код создает два объекта Book: my_book и my_book2. Метод input_data используется для ввода данных для my_book, а функция print - для вывода значений всех атрибутов с помощью метода __str__. Функция repr используется для вывода представления объекта с помощью метода __repr__.

## Объект my_book2 создается с заранее заданными значениями атрибутов, а функция print используется для вывода значений всех атрибутов с помощью метода __str__.

## Наконец, код сравнивает два объекта с помощью оператора ==, который вызывает метод __eq__. Результат сравнения выводится на печать.

## Ниже приводится пошаговое описание того, что происходит при выполнении кода:

## Определяется класс Book с его атрибутами и методами.
## Создается объект my_book без начальных значений.
## У my_book вызывается метод input_data, предлагающий пользователю ввести данные для атрибутов книги.
## Пользователь вводит данные для атрибутов книги, и полученные значения присваиваются соответствующим атрибутам my_book.
## Функция print используется для вывода значений всех атрибутов my_book с помощью метода __str__.
## Функция repr используется для вывода представления my_book с помощью метода __repr__.
## Объект my_book2 создается с заранее заданными значениями для его атрибутов.
## Функция print используется для вывода значений всех атрибутов my_book2 с помощью метода __str__.
## Для сравнения my_book и my_book2 используется оператор ==, который вызывает метод __eq__.










## Задание 3
## К уже реализованному классу «Стадион» добавьте
## конструктор, а также необходимые перегруженные методы.







# class Stadium:
#     def __init__(self, name=None, location=None, capacity=None, opened_year=None, description=None):
#         self.name = name
#         self.location = location
#         self.capacity = capacity
#         self.opened_year = opened_year
#         self.description = description

#     def __str__(self):
#         return f"Название: {self.name}, Местоположение: {self.location}, Вместимость: {self.capacity}, Год открытия: {self.opened_year}, Описание: {self.description}"

#     def __repr__(self):
#         return f"Stadium('{self.name}', '{self.location}', {self.capacity}, {self.opened_year}, '{self.description}')"

#     def __eq__(self, other):
#         return self.name == other.name and self.location == other.location

#     def input_data(self):
#         self.name = input("Введите название стадиона: ")
#         self.location = input("Введите местоположение стадиона: ")
#         self.capacity = int(input("Введите вместимость стадиона: "))
#         self.opened_year = int(input("Введите год открытия стадиона: "))
#         self.description = input("Введите описание стадиона: ")

#     def output_data(self):
#         print(f"Название: {self.name}")
#         print(f"Местоположение: {self.location}")
#         print(f"Вместимость: {self.capacity}")
#         print(f"Год открытия: {self.opened_year}")
#         print(f"Описание: {self.description}")

#     def get_name(self):
#         return self.name

#     def get_location(self):
#         return self.location

#     def get_capacity(self):
#         return self.capacity

#     def get_opened_year(self):
#         return self.opened_year

#     def get_description(self):
#         return self.description

# # Создаем объект Stadium и вводим данные
# my_stadium = Stadium()
# my_stadium.input_data()
# print(my_stadium)  # Используем перегруженный метод __str__
# print(repr(my_stadium))  # Используем перегруженный метод __repr__

# # Создаем другой объект Stadium
# my_stadium2 = Stadium("Лужники", "Москва", 81000, 1956, "Один из крупнейших стадионов России")
# print(my_stadium2)

# # Сравниваем два объекта Stadium
# print(my_stadium == my_stadium2)  # Используем перегруженный метод __eq__







## Определение класса

## В коде определен класс Stadium с несколькими методами и атрибутами.

## Атрибуты

## Класс имеет пять атрибутов:

## name: название стадиона
## местоположение: местоположение стадиона
## вместимость: вместимость стадиона
## opened_year: год открытия стадиона
## описание: краткое описание стадиона
## Метод __init__

## Метод __init__ - это специальный метод в Python, который вызывается при создании объекта. Он инициализирует атрибуты объекта переданными ему значениями. 
# В данном случае метод __init__ принимает пять аргументов: name, location, capacity, open_year и description. Эти аргументы присваиваются соответствующим атрибутам объекта.

## Метод __str__

## Метод __str__ - это еще один специальный метод в Python, который возвращает строковое представление объекта. В данном случае метод __str__ возвращает строку, содержащую значения всех атрибутов, отформатированную в удобном для чтения виде.

## Метод __repr__

## Метод __repr__ похож на метод __str__, но он возвращает строку, представляющую объект таким образом, что ее можно использовать для воссоздания объекта. 
# В данном случае метод __repr__ возвращает строку, содержащую значения всех атрибутов, оформленную в виде выражения Python, которое можно использовать для создания нового объекта Stadium.

## Метод __eq__

## Метод __eq__ - это специальный метод в Python, который вызывается, когда оператор == используется для сравнения двух объектов. В этом случае метод __eq__ возвращает True, если атрибуты name и location двух объектов равны, и False в противном случае.

## Метод input_data

## Метод input_data - это обычный метод, который предлагает пользователю ввести данные для атрибутов стадиона и присваивает введенные значения соответствующим атрибутам.

## Метод output_data

## Метод output_data - это обычный метод, который распечатывает значения всех атрибутов в удобном для чтения формате.

## Геттерные методы

## Класс имеет пять геттерных методов: get_name, get_location, get_capacity, get_opened_year и get_description. Эти методы просто возвращают значения соответствующих атрибутов.

## Создание объектов и использование методов

## Код создает два объекта Stadium: my_stadium и my_stadium2. Метод input_data используется для ввода данных для my_stadium, а функция print - для вывода значений всех атрибутов с помощью метода __str__. Функция repr используется для вывода представления объекта с помощью метода __repr__.

## Объект my_stadium2 создается с заранее заданными значениями атрибутов, а функция print используется для вывода значений всех атрибутов с помощью метода __str__.

## Наконец, код сравнивает два объекта с помощью оператора ==, который вызывает метод __eq__. Результат сравнения выводится на печать.









## Модуль 10 Объектно-ориентированное
## программирование
## Тема: Статические методы





## Задание 1
## К уже реализованному классу «Дробь» добавьте ста-
## тический метод, который при вызове возвращает коли-
## чество созданных объектов класса «Дробь».





# class Fraction:
#     count = 0  # статический член для подсчета объектов

#     def __init__(self, numerator, denominator):
#         self.numerator = numerator
#         self.denominator = denominator
#         Fraction.count += 1  # инкремент счетчика при создании объекта

#     def __del__(self):
#         Fraction.count -= 1  # декремент счетчика при удалении объекта

#     @staticmethod
#     def get_count():
#         return Fraction.count

#     # другие методы класса...

# f1 = Fraction(1, 2)
# f2 = Fraction(3, 4)
# f3 = Fraction(5, 6)

# print("Количество созданных объектов:", Fraction.get_count())






## Задание 2
## Создайте класс для конвертирования температуры из
## Цельсия в Фаренгейт и наоборот. У класса должно быть
## два статических метода: для перевода из Цельсия в Фа-
## ренгейт и для перевода из Фаренгейта в Цельсий. Также
## класс должен считать количество подсчетов температуры и
## возвращать это значение с помощью статического метода.





# class TemperatureConverter:
#     count = 0  # статический член для подсчета количества конверсий

#     @staticmethod
#     def celsius_to_fahrenheit(celsius):
#         TemperatureConverter.count += 1  # инкремент счетчика
#         return (celsius * 9/5) + 32

#     @staticmethod
#     def fahrenheit_to_celsius(fahrenheit):
#         TemperatureConverter.count += 1  # инкремент счетчика
#         return (fahrenheit - 32) * 5/9

#     @staticmethod
#     def get_conversion_count():
#         return TemperatureConverter.count

# # пример использования
# print(TemperatureConverter.celsius_to_fahrenheit(30))  # 86.0
# print(TemperatureConverter.fahrenheit_to_celsius(86))  # 30.0
# print(TemperatureConverter.get_conversion_count())  # 2





## Задание 3
## Создайте класс для перевода из метрической системы
## в английскую и наоборот. Функциональность необходимо
## реализовать в виде статических методов. Обязательно
## реализуйте перевод мер длины.




# class UnitConverter:
#     count = 0  # статический член для подсчета количества конверсий

#     @staticmethod
#     def meter_to_foot(meter):
#         UnitConverter.count += 1  # инкремент счетчика
#         return meter * 3.28084

#     @staticmethod
#     def foot_to_meter(foot):
#         UnitConverter.count += 1  # инкремент счетчика
#         return foot / 3.28084

#     @staticmethod
#     def kilogram_to_pound(kilogram):
#         UnitConverter.count += 1  # инкремент счетчика
#         return kilogram * 2.20462

#     @staticmethod
#     def pound_to_kilogram(pound):
#         UnitConverter.count += 1  # инкремент счетчика
#         return pound / 2.20462

#     @staticmethod
#     def liter_to_gallon(liter):
#         UnitConverter.count += 1  # инкремент счетчика
#         return liter * 0.264172

#     @staticmethod
#     def gallon_to_liter(gallon):
#         UnitConverter.count += 1  # инкремент счетчика
#         return gallon / 0.264172

#     @staticmethod
#     def get_conversion_count():
#         return UnitConverter.count

# # пример использования
# print(UnitConverter.meter_to_foot(10))  # 32.8084
# print(UnitConverter.foot_to_meter(32.8084))  # 10.0
# print(UnitConverter.kilogram_to_pound(5))  # 11.0231
# print(UnitConverter.pound_to_kilogram(11.0231))  # 5.0
# print(UnitConverter.liter_to_gallon(5))  # 1.32086
# print(UnitConverter.gallon_to_liter(1.32086))  # 5.0
# print(UnitConverter.get_conversion_count())  # 6


# В этом примере класс UnitConverter имеет шесть статических методов для перевода между метрической и английской системами мер:

# meter_to_foot и foot_to_meter для перевода мер длины
# kilogram_to_pound и pound_to_kilogram для перевода мер массы
# liter_to_gallon и gallon_to_liter для перевода мер объема
# Каждый раз, когда вызывается один из этих методов, счетчик count инкрементируется.

## Статический метод get_conversion_count возвращает текущее значение счетчика, которое отображает количество выполненных конверсий.


## Класс UnitConverter

## В этом коде мы создаем класс под названием UnitConverter. Класс - это как контейнер, который содержит данные и функции, которые могут работать с этими данными.

## Статические члены

## В классе мы создаем статический член count, который будет хранить количество конверсий, которые мы выполняем. Статические члены - это члены класса, которые не зависят от конкретного объекта класса.

## Статические методы

## В классе мы создаем шесть статических методов:

## meter_to_foot: переводит метры в футы
## foot_to_meter: переводит футы в метры
## kilogram_to_pound: переводит килограммы в фунты
## pound_to_kilogram: переводит фунты в килограммы
## liter_to_gallon: переводит литры в галлоны
## gallon_to_liter: переводит галлоны в литры
## Каждый из этих методов принимает один аргумент (например, meter для meter_to_foot) и возвращает результат конверсии.

## Инкремент счетчика

## В каждом из статических методов мы инкрементируем счетчик count на 1. Это означает, что каждый раз, когда мы вызываем один из этих методов, счетчик увеличивается на 1.

## Метод get_conversion_count

## Метод get_conversion_count возвращает текущее значение счетчика count. Это позволяет нам узнать, сколько раз мы выполняли конверсии.

## Пример использования

## В примере использования мы вызываем каждый из статических методов и печатаем результаты. Затем мы вызываем метод get_conversion_count и печатаем количество выполненных конверсий.

## Вот что происходит в этом коде:

## Мы создаем класс UnitConverter с статическим членом count и шестью статическими методами для конверсии единиц измерения.
## Мы вызываем каждый из статических методов и печатаем результаты.
## Каждый раз, когда мы вызываем статический метод, счетчик count увеличивается на 1.
## Мы вызываем метод get_conversion_count и печатаем количество выполненных конверсий.



## Модуль 12 Паттерны проектирования
## Тема: Паттерны проектирования. Часть 1



## Паттерны проектирования (Design Patterns) - это повторно используемые решения для иных проблем, которые возникают при разработке программного обеспечения. 
# Они представляют собой проверенные и испытанные подходы к решению определенных задач, которые могут быть применены в различных контекстах.

## Паттерны проектирования помогают разработчикам создавать  flexible, maintainable и scalable системы, уменьшая количество ошибок и улучшая общую архитектуру программного обеспечения.

## Паттерны проектирования могут быть разделены на несколько категорий:

## 1)Creational Patterns (Паттерны создания): они связаны с созданием объектов и управлением их жизненным циклом.
## 2)Structural Patterns (Паттерны структуры): они связаны с организацией классов и объектов в систему.
## 3)Behavioral Patterns (Паттерны поведения): они связаны с взаимодействием объектов и реализацией алгоритмов.
## 4)Давайте рассмотрим некоторые из наиболее популярных паттернов проектирования:

## Creational Patterns

## 5)Singleton Pattern (Паттерн одиночки): обеспечивает создание только одного экземпляра класса и предоставляет глобальный доступ к нему.
## 6)Factory Pattern (Паттерн фабрики): обеспечивает создание объектов без указания конкретного класса, используя фабрику.
## 7)Abstract Factory Pattern (Паттерн абстрактной фабрики): обеспечивает создание семейств объектов, связанных между собой.

## Structural Patterns

## 8)Adapter Pattern (Паттерн адаптера): позволяет объектам с несовместимыми интерфейсами работать вместе.
## 9)Bridge Pattern (Паттерн моста): разделяет абстракцию и реализацию, чтобы изменять их независимо.
## 10)Composite Pattern (Паттерн композиции): позволяет клиентскому коду работать с объектами, состоящими из других объектов.
## 11)Decorator Pattern (Паттерн декоратора): позволяет добавлять поведение к объекту без изменения его класса.
## 12)Facade Pattern (Паттерн фасада): предоставляет упрощенный интерфейс к сложной системе.
## 13)Flyweight Pattern (Паттерн летучей мыши): позволяет экономить ресурсы, разделяя общую информацию между объектами.
## 14)Proxy Pattern (Паттерн прокси): предоставляет контроль над доступом к объекту.
## 15)Template Method Pattern (Паттерн шаблона метода): определяет шаблон алгоритма, позволяя подклассам расширить его.

## Behavioral Patterns

## 16)Observer Pattern (Паттерн наблюдателя): позволяет объектам получать уведомления о изменениях в других объектах.
## 17)Strategy Pattern (Паттерн стратегии): позволяет изменять алгоритм, используемый объектом, без изменения его кода.
## 18)Template Method Pattern (Паттерн шаблонного метода): позволяет изменять шаги алгоритма, не изменяя его общую структуру.


## Преимущества использования паттернов проектирования:

## Улучшение flexibility и maintainability системы
## Уменьшение количества ошибок и улучшение общей архитектуры
## Повышение производительности и эффективности разработки
## Облегчение понимания и поддержки кода
## Недостатки использования паттернов проектирования:

## Увеличение сложности кода
## Требуется дополнительное время и усилия для изучения и применения паттернов
## Необходимость тщательного планирования и проектирования системы
## В целом, паттерны проектирования - это мощный инструмент для разработчиков, который помогает создавать болееflexible, maintainable и scalable системы.
#  Однако, их применение требует тщательного планирования и проектирования, а также дополнительного времени и усилий для изучения и применения.






## Задание 1
## Создайте реализацию паттерна Builder. Протестируйте
## работу созданного класса.



# class Car:
#     def __init__(self):
#         self.make = None
#         self.model = None
#         self.year = None
#         self.color = None

#     def __str__(self):
#         return f"Car: {self.year} {self.color} {self.make} {self.model}"

# class CarBuilder:
#     def __init__(self):
#         self.car = Car()

#     def set_make(self, make):
#         self.car.make = make
#         return self

#     def set_model(self, model):
#         self.car.model = model
#         return self

#     def set_year(self, year):
#         self.car.year = year
#         return self

#     def set_color(self, color):
#         self.car.color = color
#         return self

#     def build(self):
#         return self.car

# # Testing the CarBuilder class
# builder = CarBuilder()
# car = (builder
#        .set_make("Toyota")
#        .set_model("Camry")
#        .set_year(2022)
#        .set_color("Silver")
#        .build())

# print(car)  # Output: Car: 2022 Silver Toyota Camry

















## Задание 2
## Создайте приложение для приготовления пасты. При-
## ложение должно уметь создавать минимум три вида па-
## сты. Классы различной пасты должны иметь следующие
## методы:
## ■ Тип пасты;
## ■ Соус;
## ■ Начинка;
## ■ Добавки.
## Для реализации используйте порождающие паттерны.








# Базовый класс Pasta (Паста)
# class Pasta:
#     def __init__(self):
#         self.type = None
#         self.sauce = None
#         self.stuffing = None
#         self.additions = None

#     def set_type(self, pasta_type):
#         self.type = pasta_type

#     def set_sauce(self, sauce):
#         self.sauce = sauce

#     def set_stuffing(self, stuffing):
#         self.stuffing = stuffing

#     def set_additions(self, additions):
#         self.additions = additions

#     def get_recipe(self):
#         return f"Тип пасты: {self.type}\nСоус: {self.sauce}\nНачинка: {self.stuffing}\nДобавки: {', '.join(self.additions)}"

# # Классы конкретных видов пасты
# class Spaghetti(Pasta):
#     def __init__(self):
#         super().__init__()
#         self.set_type("Спагетти")

# class Penne(Pasta):
#     def __init__(self):
#         super().__init__()
#         self.set_type("Пенне")

# class Fettuccine(Pasta):
#     def __init__(self):
#         super().__init__()
#         self.set_type("Феттуччине")

# # Функция для создания пасты по выбору пользователя
# def create_pasta():
#     print("Добро пожаловать в приложение для приготовления пасты!")
#     print("Выберите тип пасты:")
#     print("1. Спагетти")
#     print("2. Пенне")
#     print("3. Феттуччине")
    
#     choice = input("Введите номер (1-3): ")
    
#     if choice == '1':
#         pasta = Spaghetti()
#     elif choice == '2':
#         pasta = Penne()
#     elif choice == '3':
#         pasta = Fettuccine()
#     else:
#         print("Неверный выбор!")
#         return

#     # Пользователь выбирает соус
#     sauce = input("Введите соус: ")
#     pasta.set_sauce(sauce)

#     # Пользователь выбирает начинку
#     stuffing = input("Введите начинку: ")
#     pasta.set_stuffing(stuffing)

#     # Пользователь выбирает добавки
#     additions = input("Введите добавки (через запятую): ").split(",")
#     pasta.set_additions([addition.strip() for addition in additions])

#     # Выводим готовый рецепт
#     print("\nВаш рецепт:")
#     print(pasta.get_recipe())

# # Основное меню
# def main_menu():
#     while True:
#         print("\n--- Меню ---")
#         print("1. Создать пасту")
#         print("2. Выйти")
#         choice = input("Введите номер (1-2): ")

#         if choice == '1':
#             create_pasta()
#         elif choice == '2':
#             print("До свидания!")
#             break
#         else:
#             print("Неверный выбор! Попробуйте снова.")

# if __name__ == "__main__":
#     main_menu()




## Объяснение по пунктам:

## Класс Pasta (базовый класс для всех типов пасты):

## Этот класс содержит общие методы для всех видов пасты: установка типа пасты, соуса, начинки и добавок.

#3 Метод get_recipe выводит полный рецепт пасты.

## Классы Spaghetti, Penne и Fettuccine (конкретные виды пасты):

## Эти классы наследуются от базового класса Pasta. Каждый из них устанавливает свой уникальный тип пасты в конструкторе (__init__), вызывая метод set_type.

## Это позволяет автоматически указать, какой тип пасты был выбран.

## Функция create_pasta:

## Пользователь выбирает тип пасты (Спагетти, Пенне или Феттуччине).

## После выбора типа пасты программа запрашивает у пользователя соус, начинку и добавки.

## Используя методы из класса Pasta, эти данные сохраняются в объекте.

## В конце программа выводит готовый рецепт пасты на экран.

## Функция main_menu:

## Это основное меню программы. 
## Пользователь может выбрать, создать пасту или выйти из приложения.

## В цикле while True программа повторяет меню, пока пользователь не выберет выход.
























## Задание 3
## Создайте реализацию паттерна Prototype. Протести-
## руйте работу созданного класса.






# import copy

# # Класс, который будет поддерживать копирование объектов (паттерн Prototype)
# class Prototype:
#     def __init__(self, name, attributes):
#         self.name = name  # Имя объекта (например, название прототипа)
#         self.attributes = attributes  # Словарь с характеристиками объекта

#     # Метод для клонирования объекта (создание копии)
#     def clone(self):
#         # Используем deepcopy для полного копирования объекта и его вложенных структур данных
#         return copy.deepcopy(self)

#     # Метод для отображения информации об объекте
#     def display(self):
#         print(f"\nИмя объекта: {self.name}")
#         print(f"Характеристики: {self.attributes}")


# # Функция для создания и клонирования объекта-прототипа
# def prototype_menu():
#     print("\n--- Пример паттерна Prototype ---")

#     # Создаем оригинальный объект
#     name = input("Введите имя оригинального объекта: ")
#     color = input("Введите цвет оригинального объекта: ")
#     size = input("Введите размер оригинального объекта: ")

#     # Создаем оригинал на основе данных пользователя
#     original = Prototype(name, {"цвет": color, "размер": size})
    
#     print("\nОригинальный объект:")
#     original.display()

#     # Клонируем оригинальный объект
#     clone = original.clone()
#     clone.name = input("\nВведите новое имя для клонированного объекта: ")

#     # Пользователь может изменить характеристики клонированного объекта
#     change_color = input("Изменить цвет клонированного объекта? (y/n): ")
#     if change_color.lower() == 'y':
#         clone.attributes['цвет'] = input("Введите новый цвет: ")

#     change_size = input("Изменить размер клонированного объекта? (y/n): ")
#     if change_size.lower() == 'y':
#         clone.attributes['размер'] = input("Введите новый размер: ")

#     print("\nКлонированный объект:")
#     clone.display()


# # Основное меню
# def main_menu():
#     while True:
#         print("\n--- Меню ---")
#         print("1. Создать и клонировать объект")
#         print("2. Выйти")
#         choice = input("Введите номер (1-2): ")

#         if choice == '1':
#             prototype_menu()
#         elif choice == '2':
#             print("До свидания!")
#             break
#         else:
#             print("Неверный выбор! Попробуйте снова.")


# # Запуск программы
# if __name__ == "__main__":
#     main_menu()







## Объяснение по пунктам:

## Класс Prototype (класс-прототип):

## Этот класс предназначен для создания объектов и их клонирования.

## В конструкторе (__init__) задаются имя объекта и его характеристики (в виде словаря).

## Метод clone использует функцию deepcopy из модуля copy, чтобы создать полную копию объекта. 
## Это гарантирует, что все вложенные структуры данных (например, словарь attributes) тоже будут скопированы.

## Метод display выводит имя и характеристики объекта.

## Функция prototype_menu:

## В этой функции происходит создание оригинального объекта, его отображение и клонирование.

## Пользователь вводит данные для оригинального объекта (имя, цвет, размер).

## Затем происходит клонирование с возможностью изменения характеристик клонированного объекта.

## Клонированный объект выводится на экран с обновлёнными данными (если они были изменены).

## Функция main_menu:

## Это главное меню программы, через которое пользователь может выбрать, создать объект и его клон или выйти из программы.

## В зависимости от выбора пользователя, вызывается функция prototype_menu или программа завершается.

## Клонирование с помощью deepcopy:

## Использование deepcopy позволяет создать полную независимую копию объекта. 
## Это важно для того, чтобы изменения в клонированном объекте не затрагивали оригинал.

















# Доп_знания №1

## Клонирование объекта в коде нужно для создания копии существующего объекта с сохранением всех его свойств и состояний,
## при этом новая копия будет независима от оригинала. Это особенно полезно, 
## когда требуется создать новый объект на основе существующего, но с возможностью модификации, не влияя на исходный объект.





## Зачем нужно клонирование объектов:
## Избежание повторного создания сложных объектов.
## Некоторые объекты могут быть созданы через долгие вычисления или сложную настройку (например, инициализация больших данных).
## Клонирование позволяет быстро создать новый объект, основанный на уже существующем, вместо того чтобы проходить весь процесс создания с нуля.





## Создание независимых копий:
## Клонирование с помощью deepcopy создает глубокую копию, что означает, что изменения в копии объекта не влияют на оригинал.
## Это особенно важно, если объект содержит вложенные структуры данных (например, списки, словари), которые могут быть изменены.





## Экономия времени и ресурсов:
## Когда необходимо создать несколько похожих объектов с небольшими изменениями, проще клонировать существующий объект и внести изменения,
## чем каждый раз создавать новый объект с нуля.



## Работа с шаблонами (прототипами):
## В паттерне Prototype объект служит шаблоном (прототипом), 
## который можно многократно клонировать. 
## Это помогает, когда нужно создавать несколько похожих объектов на основе одного прототипа с минимальными изменениями.



## Гарантия безопасности данных:
## Если объекты передаются между различными частями программы, клонирование позволяет быть уверенным,
## что каждая часть программы работает с независимой копией данных, предотвращая нежелательные изменения в исходных объектах.




## Пример:

## Допустим, у вас есть сложный объект — автомобиль с множеством характеристик.
## Вы хотите создать ещё один автомобиль на основе этого, но поменять только цвет:


# car1 = Prototype("Car 1", {"цвет": "Красный", "мощность": "200 л.с."})
# car2 = car1.clone()  # Клонируем оригинальный объект
# car2.attributes["цвет"] = "Синий"  # Изменяем цвет клонированного объекта

# # car1 и car2 — это теперь два независимых объекта
# print(car1.attributes)  # {'цвет': 'Красный', 'мощность': '200 л.с.'}
# print(car2.attributes)  # {'цвет': 'Синий', 'мощность': '200 л.с.'}


## В этом примере клонирование позволило создать копию автомобиля с изменением цвета без необходимости 
## создания нового автомобиля с нуля и без изменений в оригинальном объекте.













# Доп_знания №2

## В коде строка self.attributes = attributes используется для хранения характеристик объекта в виде словаря (dictionary).
## Этот словарь содержит различные свойства объекта, такие как цвет, размер, мощность и т.д. 
## В объектно-ориентированном программировании словари удобны для хранения множества свойств, 
## которые могут быть разными для каждого экземпляра объекта.


## Почему используется словарь и для чего это нужно?


## Гибкость хранения данных:
## Словарь позволяет хранить произвольное количество пар "ключ-значение".
## Это означает, что каждый объект может иметь разное количество характеристик,
## и вы легко можете добавлять новые свойства или изменять существующие.


## Структурированность данных:
## Каждой характеристике объекта дается уникальное имя (ключ), например, "цвет" или "размер". 
## Это упрощает доступ к этим свойствам. Например, вы можете запросить цвет объекта с помощью self.attributes["цвет"].


## Универсальность объекта:
## Вместо того чтобы создавать отдельные переменные для каждого свойства (например, self.color, self.size и т.д.),
## используется один словарь, который может динамически изменяться и содержать любое количество характеристик.
## Это делает объект более универсальным и легко расширяемым.





## Пример с использованием словаря attributes:



# class Prototype:
#     def __init__(self, name, attributes):
#         self.name = name  # Имя объекта (например, название машины)
#         self.attributes = attributes  # Словарь с характеристиками машины





## Когда создается объект этого класса, его характеристики передаются в виде словаря:



# car1 = Prototype("Car 1", {"цвет": "Красный", "мощность": "200 л.с.", "вес": "1.5 т"})



## Здесь в словаре хранятся:

## Ключи: "цвет", "мощность", "вес" — это названия характеристик.
## Значения: "Красный", "200 л.с.", "1.5 т" — это значения характеристик.




## Доступ к характеристикам:
## Вы можете легко получить или изменить характеристику:




# print(car1.attributes["цвет"])  # Вывод: Красный

## # Изменение мощности:
# car1.attributes["мощность"] = "250 л.с."





## Преимущества использования словаря attributes:
## Легкость добавления новых характеристик:

## Если вам нужно добавить новое свойство, вы просто добавляете его в словарь:



# car1.attributes["количество дверей"] = 4



## Динамическая природа объекта:

## Вы можете изменять, удалять или добавлять свойства в процессе работы программы, что делает объект очень гибким.



# Чистота кода:

# Вместо создания множества отдельных переменных, все свойства объекта хранятся в одном месте (в словаре), что упрощает работу с данными.
# Заключение:



# Словарь attributes используется для того,
# чтобы структурированно и удобно хранить характеристики объекта,
# давая возможность динамически добавлять, изменять и удалять свойства объекта во время выполнения программы.















## Модуль 12 Паттерны проектирования
## Тема: Паттерны проектирования. Часть 2








## Задание 1
## Создайте реализацию паттерна Command. Протести-
## руйте работу созданного класса.




# Интерфейс команды
# class Command:
#     def execute(self):
#         raise NotImplementedError("Метод execute() должен быть переопределен")

# # Конкретная команда - Включить свет
# class TurnOnLightCommand(Command):
#     def __init__(self, light):
#         self.light = light

#     def execute(self):
#         self.light.turn_on()

# # Конкретная команда - Выключить свет
# class TurnOffLightCommand(Command):
#     def __init__(self, light):
#         self.light = light

#     def execute(self):
#         self.light.turn_off()

# # Класс приемник (тот, на кого действуют команды) - Свет
# class Light:
#     def turn_on(self):
#         print("Свет включен")

#     def turn_off(self):
#         print("Свет выключен")

# # Класс Invoker — вызывает команды
# class RemoteControl:
#     def __init__(self):
#         self.command = None

#     # Устанавливаем команду
#     def set_command(self, command):
#         self.command = command

#     # Выполняем команду
#     def press_button(self):
#         if self.command:
#             self.command.execute()
#         else:
#             print("Команда не установлена")

# # Функция для тестирования паттерна Command с меню
# def command_menu():
#     light = Light()
#     remote = RemoteControl()

#     while True:
#         print("\n--- Меню управления светом ---")
#         print("1. Включить свет")
#         print("2. Выключить свет")
#         print("3. Выйти")
#         choice = input("Введите номер (1-3): ")

#         if choice == '1':
#             # Создаем команду включения света и передаем ее пульту
#             command = TurnOnLightCommand(light)
#             remote.set_command(command)
#             remote.press_button()

#         elif choice == '2':
#             # Создаем команду выключения света и передаем ее пульту
#             command = TurnOffLightCommand(light)
#             remote.set_command(command)
#             remote.press_button()

#         elif choice == '3':
#             print("Выход...")
#             break

#         else:
#             print("Неверный выбор! Попробуйте снова.")

# # Запуск программы
# if __name__ == "__main__":
#     command_menu()





## Объяснение по пунктам:

## Интерфейс команды (Command):
## Этот класс представляет собой абстрактный класс с методом execute,
## который должен быть переопределен в подклассах. 
## Он задает общую структуру для всех команд, но сам не выполняет никаких действий.

## Классы команд (TurnOnLightCommand и TurnOffLightCommand):
## Это конкретные команды, которые реализуют метод execute. 
## Каждая команда содержит ссылку на объект, на который она будет воздействовать — в данном случае, 
## это объект Light.
## Команда TurnOnLightCommand вызывает метод turn_on у объекта Light, а TurnOffLightCommand — метод turn_off.

## Класс Light (Приемник):
## Это класс, представляющий объект, который принимает команды. 
## В данном примере, это лампочка с методами turn_on и turn_off,
## которые фактически выполняют действия включения и выключения света.

## Класс RemoteControl (Invoker):
## Этот класс представляет собой "пульт управления". 
## Он содержит команду, которую можно установить с помощью метода set_command.
## Когда пользователь нажимает кнопку (press_button), команда выполняется.
## Это позволяет вызывать разные команды с помощью одного и того же объекта RemoteControl, просто меняя команду.

## Функция command_menu:
## Эта функция предоставляет пользователю меню для выбора действий.
## В зависимости от выбора, создается соответствующая команда,
## которая передается объекту RemoteControl для выполнения.
## В функции реализован цикл, который позволяет повторять выбор действий до тех пор, 
## пока пользователь не выберет выход.

## Зачем нужен паттерн Command:
## Он инкапсулирует запросы в виде объектов, что позволяет отделить логику отправителя команды от логики получателя.
## Он облегчает добавление новых команд без необходимости изменять существующий код.
## Команды можно легко сохранить, отменить или повторить.









# Доп_знания №3

# def press_button(self):
#         if self.command:
#             self.command.execute()
#         else:
#             print("Команда не установлена")




## Метод press_button — это функция в классе RemoteControl. 
## Этот класс предназначен для управления командами.
## Команды могут быть разными действиями, которые можно выполнить, например, включение или выключение света.

## Что делает метод press_button:
## Проверка наличия команды (if self.command:):

## self.command — это переменная, которая хранит команду, которую нужно выполнить.
## Вначале эта переменная может быть пустой, если команда не установлена.

## Условие if self.command: проверяет, есть ли команда, которую можно выполнить. 
## Если self.command содержит какую-то команду (т.е. не является пустым значением), условие будет истинным.

## Выполнение команды (self.command.execute()):
## Если команда установлена (то есть self.command не пустое), метод execute() этой команды вызывается. 
## Это фактически выполняет действие, которое команда представляет.
## Например, если команда — это включение света, то метод execute() вызовет функцию включения света.

## Сообщение об ошибке (else:):
## Если self.command пустой (то есть команда не установлена), выполняется часть кода после else.
## В этом случае выводится сообщение "Команда не установлена".
## Это информирует пользователя о том, что нет команды для выполнения.






## Пример:
## Представьте, что вы используете пульт управления (объект RemoteControl), чтобы включить или выключить свет. 
## Вот как это работает:

## Вы создаете команду для включения света и передаете её пульту управления.
## Когда вы нажимаете кнопку на пульте, вызывается метод press_button.
## Если на пульте установлена команда, метод press_button выполнит её.
##  В противном случае, если команда не была установлена, вы получите сообщение о том, что команда не установлена.




# class Light:
#     def turn_on(self):
#         print("Свет включен")

#     def turn_off(self):
#         print("Свет выключен")

# class TurnOnLightCommand:
#     def __init__(self, light):
#         self.light = light

#     def execute(self):
#         self.light.turn_on()

# class RemoteControl:
#     def __init__(self):
#         self.command = None

#     def set_command(self, command):
#         self.command = command

#     def press_button(self):
#         if self.command:
#             self.command.execute()
#         else:
#             print("Команда не установлена")

# # Создаем объекты
# light = Light()
# command = TurnOnLightCommand(light)
# remote = RemoteControl()

# # Устанавливаем команду и нажимаем кнопку
# remote.set_command(command)
# remote.press_button()  # Вывод: Свет включен

# # Не устанавливаем команду и нажимаем кнопку
# remote.set_command(None)
# remote.press_button()  # Вывод: Команда не установлена



## Подведение итогов:

## Метод press_button проверяет, установлена ли команда.
## Если команда установлена, она выполняется.
## Если команда не установлена, выводится сообщение об ошибке.
## Это помогает обеспечить, чтобы программа работала корректно и пользователь знал, когда команда не была задана.





## Задание 2
## Есть класс, предоставляющий доступ к набору чисел.
## Источником этого набора чисел является некоторый
## файл. С определенной периодичностью данные в файле
## меняются (надо реализовать механизм обновления).
## Приложение должно получать доступ к этим данным и
## выполнять набор операций над ними (сумма, максимум,
## минимум и т.д.). При каждой попытке доступа к этому
## набору необходимо вносить запись в лог-файл. При ре-
## ализации используйте паттерн Proxy (для логгирования)
## и другие необходимые паттерны.










## Для реализации задачи мы будем использовать паттерн Proxy для логирования доступа к набору чисел,
## а также паттерны Singleton и Observer для управления обновлением данных.
## Приложение будет следовать следующим шагам:




## (1)Создадим интерфейс для работы с данными.

## (2)Реализуем класс, который предоставляет доступ к набору чисел.

## (3)Реализуем прокси-класс для логирования доступа.

## (4)Создадим класс для обновления данных и ведения логов.

## (5)Добавим меню для взаимодействия с пользователем.


# import os
# import time
# import random
# from abc import ABC, abstractmethod

# # Интерфейс для работы с данными
# class DataProvider(ABC):
#     @abstractmethod
#     def get_data(self):
#         pass

#     @abstractmethod
#     def update_data(self):
#         pass

# # Класс для работы с набором чисел из файла
# class FileDataProvider(DataProvider):
#     def __init__(self, filename):
#         self.filename = filename

#     def get_data(self):
#         with open(self.filename, 'r') as file:
#             numbers = [int(line.strip()) for line in file]
#         return numbers

#     def update_data(self):
#         with open(self.filename, 'w') as file:
#             for _ in range(10):
#                 file.write(f"{random.randint(1, 100)}\n")

# # Прокси-класс для логирования доступа
# class LoggingProxy(DataProvider):
#     def __init__(self, real_subject):
#         self.real_subject = real_subject

#     def get_data(self):
#         self._log("Get data accessed")
#         return self.real_subject.get_data()

#     def update_data(self):
#         self._log("Update data accessed")
#         self.real_subject.update_data()

#     def _log(self, message):
#         with open('access.log', 'a') as log_file:
#             log_file.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - {message}\n")

# # Синглтон-класс для управления данными и их обновлением
# class DataManager:
#     _instance = None

#     def __new__(cls, *args, **kwargs):
#         if not cls._instance:
#             cls._instance = super().__new__(cls, *args, **kwargs)
#         return cls._instance

#     def __init__(self):
#         self.provider = LoggingProxy(FileDataProvider('numbers.txt'))

#     def get_numbers(self):
#         return self.provider.get_data()

#     def update_numbers(self):
#         self.provider.update_data()

# # Функции для операций над данными
# def get_sum(numbers):
#     return sum(numbers)

# def get_max(numbers):
#     return max(numbers)

# def get_min(numbers):
#     return min(numbers)

# # Функция для взаимодействия с пользователем
# def menu():
#     manager = DataManager()
    
#     while True:
#         print("\n--- Меню ---")
#         print("1. Получить данные")
#         print("2. Обновить данные")
#         print("3. Выполнить операции")
#         print("4. Выход")
#         choice = input("Введите номер (1-4): ")

#         if choice == '1':
#             data = manager.get_numbers()
#             print("Данные получены.")
#             print(data)
        
#         elif choice == '2':
#             manager.update_numbers()
#             print("Данные обновлены.")

#         elif choice == '3':
#             data = manager.get_numbers()
#             if data:
#                 print("Выберите операцию:")
#                 print("1. Сумма")
#                 print("2. Максимум")
#                 print("3. Минимум")
#                 op_choice = input("Введите номер (1-3): ")

#                 if op_choice == '1':
#                     print(f"Сумма: {get_sum(data)}")
#                 elif op_choice == '2':
#                     print(f"Максимум: {get_max(data)}")
#                 elif op_choice == '3':
#                     print(f"Минимум: {get_min(data)}")
#                 else:
#                     print("Неверный выбор!")
#             else:
#                 print("Нет данных для выполнения операции.")

#         elif choice == '4':
#             print("Выход...")
#             break

#         else:
#             print("Неверный выбор! Попробуйте снова.")

# # Запуск программы
# if __name__ == "__main__":
#     menu()






## 1. Импорт модулей:






# import os
# import time
# import random
# from abc import ABC, abstractmethod


## os: Модуль для работы с операционной системой, например, для работы с файлами.

## time: Модуль для работы с временем, например, для записи временных меток.

## random: Модуль для генерации случайных чисел, используемый для обновления данных.

## abc: Модуль для создания абстрактных базовых классов. Мы используем его для создания интерфейсов.






## 2. Интерфейс для работы с данными






# class DataProvider(ABC):
#     @abstractmethod
#     def get_data(self):
#         pass

#     @abstractmethod
#     def update_data(self):
#         pass





## class DataProvider(ABC): Определяет абстрактный базовый класс (интерфейс) для работы с данными.

## @abstractmethod: Декоратор, который указывает, что метод должен быть реализован в подклассах.

## В этом интерфейсе два метода: get_data и update_data, которые нужно реализовать в конкретных классах.








## 3. Класс для работы с набором чисел из файла






# class FileDataProvider(DataProvider):
#     def __init__(self, filename):
#         self.filename = filename

#     def get_data(self):
#         with open(self.filename, 'r') as file:
#             numbers = [int(line.strip()) for line in file]
#         return numbers

#     def update_data(self):
#         with open(self.filename, 'w') as file:
#             for _ in range(10):
#                 file.write(f"{random.randint(1, 100)}\n")




## class FileDataProvider(DataProvider): Реализует интерфейс DataProvider.
## Обеспечивает доступ к данным из файла.

## __init__(self, filename): Конструктор класса, принимает имя файла, 
## который будет использоваться для чтения и записи данных.

## get_data(self): Читает данные из файла и возвращает их в виде списка чисел.
## Каждая строка файла преобразуется в целое число.

## update_data(self): Обновляет файл, записывая в него 10 случайных чисел. 
## Старые данные в файле удаляются.








## 4. Прокси-класс для логирования доступа





# class LoggingProxy(DataProvider):
#     def __init__(self, real_subject):
#         self.real_subject = real_subject

#     def get_data(self):
#         self._log("Get data accessed")
#         return self.real_subject.get_data()

#     def update_data(self):
#         self._log("Update data accessed")
#         self.real_subject.update_data()

#     def _log(self, message):
#         with open('access.log', 'a') as log_file:
#             log_file.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - {message}\n")






## class LoggingProxy(DataProvider): Прокси-класс, который добавляет функциональность логирования к объекту FileDataProvider.

## __init__(self, real_subject): Конструктор класса, принимает объект,
## который реализует интерфейс DataProvider (например, FileDataProvider).

## get_data(self): Перед вызовом реального метода get_data записывает сообщение в лог-файл,
#3 а затем возвращает данные.

#3 update_data(self): Перед вызовом реального метода update_data записывает сообщение в лог-файл,
## а затем обновляет данные.

## _log(self, message): Записывает сообщение в лог-файл access.log с текущим временем.









## 5. Синглтон-класс для управления данными







# class DataManager:
#     _instance = None

#     def __new__(cls, *args, **kwargs):
#         if not cls._instance:
#             cls._instance = super().__new__(cls, *args, **kwargs)
#         return cls._instance

#     def __init__(self):
#         self.provider = LoggingProxy(FileDataProvider('numbers.txt'))

#     def get_numbers(self):
#         return self.provider.get_data()

#     def update_numbers(self):
#         self.provider.update_data()









## class DataManager: Класс, управляющий данными и их обновлением.
## Реализует паттерн Singleton, чтобы гарантировать, что существует только один экземпляр этого класса.

## _instance: Статическая переменная для хранения единственного экземпляра класса.

## __new__(cls, *args, **kwargs): Переопределяет создание объекта.
## Если экземпляр класса еще не создан, создается новый, иначе возвращается уже существующий.

## __init__(self): Конструктор класса, создает объект LoggingProxy, который оборачивает FileDataProvider.

## get_numbers(self): Использует прокси для получения данных.

## update_numbers(self): Использует прокси для обновления данных.










## 6. Функции для операций над данными






# def get_sum(numbers):
#     return sum(numbers)

# def get_max(numbers):
#     return max(numbers)

# def get_min(numbers):
#     return min(numbers)





## get_sum(numbers): Возвращает сумму всех чисел в списке.

## get_max(numbers): Возвращает максимальное число в списке.

## get_min(numbers): Возвращает минимальное число в списке.









## 7. Функция для взаимодействия с пользователем






# def menu():
#     manager = DataManager()
    
#     while True:
#         print("\n--- Меню ---")
#         print("1. Получить данные")
#         print("2. Обновить данные")
#         print("3. Выполнить операции")
#         print("4. Выход")
#         choice = input("Введите номер (1-4): ")

#         if choice == '1':
#             data = manager.get_numbers()
#             print("Данные получены.")
#             print(data)
        
#         elif choice == '2':
#             manager.update_numbers()
#             print("Данные обновлены.")

#         elif choice == '3':
#             data = manager.get_numbers()
#             if data:
#                 print("Выберите операцию:")
#                 print("1. Сумма")
#                 print("2. Максимум")
#                 print("3. Минимум")
#                 op_choice = input("Введите номер (1-3): ")

#                 if op_choice == '1':
#                     print(f"Сумма: {get_sum(data)}")
#                 elif op_choice == '2':
#                     print(f"Максимум: {get_max(data)}")
#                 elif op_choice == '3':
#                     print(f"Минимум: {get_min(data)}")
#                 else:
#                     print("Неверный выбор!")
#             else:
#                 print("Нет данных для выполнения операции.")

#         elif choice == '4':
#             print("Выход...")
#             break

#         else:
#             print("Неверный выбор! Попробуйте снова.")









## menu(): Основная функция для взаимодействия с пользователем.

## В цикле while True отображается меню и принимается выбор пользователя.

## choice == '1': Получает данные и выводит их.
## choice == '2': Обновляет данные в файле.
## choice == '3': Позволяет выбрать операцию (сумма, максимум, минимум) и выполняет её.
## choice == '4': Выход из программы.

## else: Сообщение о неверном выборе.

## Как это работает:
## Создание и использование классов:
## DataManager гарантирует, что всегда используется один и тот же экземпляр.
## LoggingProxy добавляет логирование к методам get_data и update_data класса FileDataProvider.


## Взаимодействие с пользователем:
## Пользователь выбирает действия через меню.
## Программа выполняет выбранные действия и отображает результаты.




## Эта структура позволяет управлять данными, отслеживать доступ и выполнять операции, 
## сохраняя при этом код организованным и легко расширяемым.










## Модуль 13. MVC
## Тема: MVC 








# Задание 1
# Создайте класс Обувь. Необходимо хранить следую-
# щую информацию:
# ■ тип обуви;
# ✓мужская,
# ✓женская;
# ■ вид обуви (кроссовки, сапоги, сандалии, туфли и т.д.);
# ■ цвет;
# ■ цена;
# ■ производитель;
# ■ размер.
# Создайте необходимые методы для этого класса. Реа-
# лизуйте паттерн MVC для класса Обувь и код для исполь-
# зования модели, контроллера и представления.

















# Модель (Model)

# class Shoe:
#     def __init__(self, gender: str, shoe_type: str, color: str, price: float, manufacturer: str, size: int):
#         """Конструктор для создания объекта обуви с начальными атрибутами."""
#         self.gender = gender            # Пол обуви (мужская или женская)
#         self.shoe_type = shoe_type      # Тип обуви (кроссовки, сапоги и т.д.)
#         self.color = color              # Цвет обуви
#         self.price = price              # Цена обуви
#         self.manufacturer = manufacturer # Производитель обуви
#         self.size = size                # Размер обуви

#     # Методы для изменения атрибутов
#     def set_gender(self, gender: str):
#         """Метод для изменения пола обуви (мужская/женская)."""
#         self.gender = gender

#     def set_shoe_type(self, shoe_type: str):
#         """Метод для изменения типа обуви (кроссовки, сапоги и т.д.)."""
#         self.shoe_type = shoe_type

#     def set_color(self, color: str):
#         """Метод для изменения цвета обуви."""
#         self.color = color

#     def set_price(self, price: float):
#         """Метод для изменения цены обуви."""
#         self.price = price

#     def set_manufacturer(self, manufacturer: str):
#         """Метод для изменения производителя обуви."""
#         self.manufacturer = manufacturer

#     def set_size(self, size: int):
#         """Метод для изменения размера обуви."""
#         self.size = size

#     def get_info(self):
#         """Метод для получения информации об обуви в виде словаря."""
#         return {
#             "Gender": self.gender,
#             "Shoe Type": self.shoe_type,
#             "Color": self.color,
#             "Price": self.price,
#             "Manufacturer": self.manufacturer,
#             "Size": self.size
#         }


# # Библиотека для хранения информации об обуви
# class ShoeLibrary:
#     def __init__(self):
#         """Конструктор для создания объекта библиотеки обуви."""
#         self.shoes = []  # Список для хранения всех записей об обуви

#     def add_shoe(self, shoe: Shoe):
#         """Добавляет объект обуви в библиотеку."""
#         self.shoes.append(shoe)

#     def display_all_shoes(self):
#         """Отображает информацию обо всех парах обуви в библиотеке."""
#         if not self.shoes:
#             print("Библиотека пуста.")
#         else:
#             for idx, shoe in enumerate(self.shoes):
#                 print(f"\nЗапись {idx + 1}:")
#                 shoe_info = shoe.get_info()
#                 for key, value in shoe_info.items():
#                     print(f"{key}: {value}")
#             print("\n")

# # Представление (View)
# class ShoeView:
#     @staticmethod
#     def display_shoe_info(shoe_info: dict):
#         """Отображает информацию об одной паре обуви."""
#         print("Shoe Information:")
#         for key, value in shoe_info.items():
#             print(f"{key}: {value}")


# # Контроллер (Controller)
# class ShoeController:
#     def __init__(self, model: Shoe, view: ShoeView):
#         """Инициализирует контроллер с моделью и представлением."""
#         self.model = model  # Модель обуви
#         self.view = view    # Представление для отображения данных

#     # Методы для изменения данных в модели
#     def set_gender(self, gender: str):
#         """Изменяет пол обуви через модель."""
#         self.model.set_gender(gender)

#     def set_shoe_type(self, shoe_type: str):
#         """Изменяет тип обуви через модель."""
#         self.model.set_shoe_type(shoe_type)

#     def set_color(self, color: str):
#         """Изменяет цвет обуви через модель."""
#         self.model.set_color(color)

#     def set_price(self, price: float):
#         """Изменяет цену обуви через модель."""
#         self.model.set_price(price)

#     def set_manufacturer(self, manufacturer: str):
#         """Изменяет производителя через модель."""
#         self.model.set_manufacturer(manufacturer)

#     def set_size(self, size: int):
#         """Изменяет размер обуви через модель."""
#         self.model.set_size(size)

#     # Метод для отображения информации об обуви
#     def display_shoe_info(self):
#         """Передает информацию модели в представление для отображения."""
#         shoe_info = self.model.get_info()
#         self.view.display_shoe_info(shoe_info)


# # Меню для взаимодействия с пользователем
# def menu(controller: ShoeController, library: ShoeLibrary):
#     while True:
#         print("\n1. Показать информацию об обуви")
#         print("2. Изменить тип обуви")
#         print("3. Изменить цену")
#         print("4. Изменить производителя")
#         print("5. Изменить размер")
#         print("6. Изменить цвет")
#         print("7. Изменить тип (мужская/женская)")
#         print("8. Добавить обувь в список")
#         print("9. Показать всю обувь в списке")
#         print("10. Выйти")

#         choice = input("Выберите опцию: ")

#         if choice == "1":
#             controller.display_shoe_info()
#         elif choice == "2":
#             new_type = input("Введите новый тип обуви: ")
#             controller.set_shoe_type(new_type)
#         elif choice == "3":
#             new_price = float(input("Введите новую цену: "))
#             controller.set_price(new_price)
#         elif choice == "4":
#             new_manufacturer = input("Введите нового производителя: ")
#             controller.set_manufacturer(new_manufacturer)
#         elif choice == "5":
#             new_size = int(input("Введите новый размер: "))
#             controller.set_size(new_size)
#         elif choice == "6":
#             new_color = input("Введите новый цвет: ")
#             controller.set_color(new_color)
#         elif choice == "7":
#             new_gender = input("Введите тип (мужская/женская): ")
#             controller.set_gender(new_gender)
#         elif choice == "8":
#             library.add_shoe(controller.model)
#             print("Обувь добавлена в список.")
#         elif choice == "9":
#             library.display_all_shoes()
#         elif choice == "10":
#             print("Выход...")
#             break
#         else:
#             print("Неверный выбор. Попробуйте снова.")


# # Основной блок программы
# if __name__ == "__main__":
#     # Создаем модель обуви
#     shoe = Shoe(gender="Мужская", shoe_type="Кроссовки", color="Черный", price=100.0, manufacturer="Nike", size=42)

#     # Создаем представление
#     view = ShoeView()

#     # Создаем контроллер
#     controller = ShoeController(model=shoe, view=view)

#     # Создаем библиотеку для хранения всех записей
#     library = ShoeLibrary()

#     # Запускаем меню для взаимодействия
#     menu(controller, library)


















## Класс Shoe (Модель):


## Этот класс описывает данные об одной паре обуви.
## Каждый экземпляр этого класса содержит атрибуты, такие как пол (мужская или женская), тип (кроссовки, сапоги и т.д.), цвет, цена, производитель и размер.


## Методы set_gender, set_shoe_type, set_color, set_price, set_manufacturer, set_size позволяют изменять данные объекта обуви.


## Класс ShoeLibrary:


## Этот класс хранит все созданные записи об обуви.
## Он использует список shoes для хранения объектов обуви.


## Метод add_shoe добавляет новый экземпляр обуви в библиотеку.


## Метод display_all_shoes выводит информацию обо всех парах обуви, хранящихся в библиотеке.


## Класс ShoeView (Представление):

## Этот класс отвечает за отображение информации об обуви. 
## Он получает словарь с данными об обуви и выводит их на экран через метод display_shoe_info.


## Класс ShoeController (Контроллер):


## Контроллер управляет взаимодействием между моделью и представлением.
## Он позволяет изменять данные модели через методы изменения, такие как set_gender, set_shoe_type и т.д.


## Метод display_shoe_info передает данные из модели в представление для отображения.
## Функция menu:


## Предоставляет пользователю интерфейс для взаимодействия с контроллером и библиотекой.
## Опции 1-7 позволяют изменять данные об обуви через контроллер.
## Опция 8 добавляет текущую обувь в библиотеку.
## Опция 9 выводит все записи об обуви, хранящиеся в библиотеке.
## Опция 10 завершает выполнение программы.


## Основной блок программы:
## Здесь создаются объекты модели, представления, контроллера и библиотеки.
## Функция menu предоставляет пользователю меню для изменения данных и работы с библиотекой.








## Пример работы программы:

## 1. Показать информацию об обуви
## 2. Изменить тип обуви
## 3. Изменить цену
## 4. Изменить производителя
## 5. Изменить размер
## 6. Изменить цвет
## 7. Изменить тип (мужская/женская)
## 8. Добавить обувь в библиотеку
## 9. Показать всю обувь в библиотеке
## 10. Выйти
## Выберите опцию: 1
## Shoe Information:
## Gender: Мужская
## Shoe Type: Кроссовки
## Color: Черный
## Price: 100.0
## Manufacturer: Nike
## Size: 42















## Код №2









## 1) Проверка ввода:
## Добавлены блоки try-except в местах, где пользователь вводит числовые данные (цена и размер), чтобы избежать сбоев программы при неверном вводе.

## 2) Сохранение данных:
## Метод save_to_file записывает данные библиотеки в файл shoes_data.pkl, используя библиотеку pickle.

## 3) Загрузка данных:
## Метод load_from_file загружает данные из файла, если он существует. Если файл отсутствует, программа просто начнет с пустой библиотеки.









# import pickle

# class Shoe:
#     def __init__(self, gender: str, shoe_type: str, color: str, price: float, manufacturer: str, size: int):
#         """Конструктор для создания объекта обуви с начальными атрибутами."""
#         self.gender = gender            # Пол обуви (мужская или женская)
#         self.shoe_type = shoe_type      # Тип обуви (кроссовки, сапоги и т.д.)
#         self.color = color              # Цвет обуви
#         self.price = price              # Цена обуви
#         self.manufacturer = manufacturer # Производитель обуви
#         self.size = size                # Размер обуви

#     def get_info(self):
#         """Метод для получения информации об обуви в виде словаря."""
#         return {
#             "Gender": self.gender,
#             "Shoe Type": self.shoe_type,
#             "Color": self.color,
#             "Price": self.price,
#             "Manufacturer": self.manufacturer,
#             "Size": self.size
#         }

# class ShoeLibrary:
#     def __init__(self):
#         """Конструктор для создания объекта библиотеки обуви."""
#         self.shoes = []  # Список для хранения всех записей об обуви

#     def add_shoe(self, shoe: Shoe):
#         """Добавляет объект обуви в библиотеку."""
#         self.shoes.append(shoe)

#     def display_all_shoes(self):
#         """Отображает информацию обо всех парах обуви в библиотеке."""
#         if not self.shoes:
#             print("Библиотека пуста.")
#         else:
#             for idx, shoe in enumerate(self.shoes):
#                 print(f"\nЗапись {idx + 1}:")
#                 shoe_info = shoe.get_info()
#                 for key, value in shoe_info.items():
#                     print(f"{key}: {value}")
#             print("\n")

#     def save_to_file(self, filename="shoes_data.pkl"):
#         """Сохраняет всю библиотеку в файл."""
#         with open(filename, "wb") as file:
#             pickle.dump(self.shoes, file)
#         print(f"Данные сохранены в {filename}.")

#     def load_from_file(self, filename="shoes_data.pkl"):
#         """Загружает библиотеку из файла."""
#         try:
#             with open(filename, "rb") as file:
#                 self.shoes = pickle.load(file)
#             print(f"Данные загружены из {filename}.")
#         except FileNotFoundError:
#             print("Файл не найден, начинается новая сессия.")

# # Представление (View)
# class ShoeView:
#     @staticmethod
#     def display_shoe_info(shoe_info: dict):
#         """Отображает информацию об одной паре обуви."""
#         print("Shoe Information:")
#         for key, value in shoe_info.items():
#             print(f"{key}: {value}")

# # Контроллер (Controller)
# class ShoeController:
#     def __init__(self, model: Shoe, view: ShoeView):
#         """Инициализирует контроллер с моделью и представлением."""
#         self.model = model  # Модель обуви
#         self.view = view    # Представление для отображения данных

#     def set_price(self, price: float):
#         """Изменяет цену обуви через модель."""
#         self.model.price = price

#     def set_size(self, size: int):
#         """Изменяет размер обуви через модель."""
#         self.model.size = size

#     def display_shoe_info(self):
#         """Передает информацию модели в представление для отображения."""
#         shoe_info = self.model.get_info()
#         self.view.display_shoe_info(shoe_info)

# # Меню для взаимодействия с пользователем
# def menu(controller: ShoeController, library: ShoeLibrary):
#     while True:
#         print("\n1. Показать информацию об обуви")
#         print("2. Изменить цену")
#         print("3. Изменить размер")
#         print("4. Добавить обувь в списке")
#         print("5. Показать всю обувь в списке")
#         print("6. Сохранить данные")
#         print("7. Загрузить данные")
#         print("8. Выйти")

#         choice = input("Выберите опцию: ")

#         if choice == "1":
#             controller.display_shoe_info()
#         elif choice == "2":
#             try:
#                 new_price = float(input("Введите новую цену: "))
#                 controller.set_price(new_price)
#             except ValueError:
#                 print("Ошибка: цена должна быть числом.")
#         elif choice == "3":
#             try:
#                 new_size = int(input("Введите новый размер: "))
#                 controller.set_size(new_size)
#             except ValueError:
#                 print("Ошибка: размер должен быть целым числом.")
#         elif choice == "4":
#             library.add_shoe(controller.model)
#             print("Обувь добавлена в список.")
#         elif choice == "5":
#             library.display_all_shoes()
#         elif choice == "6":
#             library.save_to_file()
#         elif choice == "7":
#             library.load_from_file()
#         elif choice == "8":
#             print("Выход...")
#             break
#         else:
#             print("Неверный выбор. Попробуйте снова.")

# # Основной блок программы
# if __name__ == "__main__":
#     # Создаем модель обуви
#     shoe = Shoe(gender="Мужская", shoe_type="Кроссовки", color="Черный", price=100.0, manufacturer="Nike", size=42)

#     # Создаем представление
#     view = ShoeView()

#     # Создаем контроллер
#     controller = ShoeController(model=shoe, view=view)

#     # Создаем библиотеку для хранения всех записей
#     library = ShoeLibrary()

#     # Загружаем данные из файла
#     library.load_from_file()

#     # Запускаем меню для взаимодействия
#     menu(controller, library)










# 1. Импорт библиотеки

# import pickle

# import pickle: Импортируем модуль pickle, который позволяет сериализовать и десериализовать объекты Python, 
# чтобы мы могли сохранять и загружать их из файлов.
















# 2. Класс Shoe

# class Shoe:
#     def __init__(self, gender: str, shoe_type: str, color: str, price: float, manufacturer: str, size: int):
#         """Конструктор для создания объекта обуви с начальными атрибутами."""
#         self.gender = gender            # Пол обуви (мужская или женская)
#         self.shoe_type = shoe_type      # Тип обуви (кроссовки, сапоги и т.д.)
#         self.color = color              # Цвет обуви
#         self.price = price              # Цена обуви
#         self.manufacturer = manufacturer # Производитель обуви
#         self.size = size                # Размер обуви

# class Shoe: Определяет класс Shoe, который представляет обувь.

# __init__: Конструктор класса, инициализирует объект с атрибутами:

# gender: пол обуви.
# shoe_type: тип обуви.
# color: цвет обуви.
# price: цена обуви.
# manufacturer: производитель обуви.
# size: размер обуви.














#     def get_info(self):
#         """Метод для получения информации об обуви в виде словаря."""
#         return {
#             "Gender": self.gender,
#             "Shoe Type": self.shoe_type,
#             "Color": self.color,
#             "Price": self.price,
#             "Manufacturer": self.manufacturer,
#             "Size": self.size
#         }


# get_info: Метод, возвращающий словарь с информацией об обуви,
# что позволяет легко получить доступ к атрибутам.









# 3. Класс ShoeLibrary

# class ShoeLibrary:
#     def __init__(self):
#         """Конструктор для создания объекта библиотеки обуви."""
#         self.shoes = []  # Список для хранения всех записей об обуви

# class ShoeLibrary: Определяет класс для управления библиотекой обуви.
# __init__: Создает пустой список shoes, который будет хранить объекты Shoe.









#     def add_shoe(self, shoe: Shoe):
#         """Добавляет объект обуви в библиотеку."""
#         self.shoes.append(shoe)

# add_shoe: Метод для добавления объекта Shoe в библиотеку (в список shoes).













#     def display_all_shoes(self):
#         """Отображает информацию обо всех парах обуви в библиотеке."""
#         if not self.shoes:
#             print("Библиотека пуста.")
#         else:
#             for idx, shoe in enumerate(self.shoes):
#                 print(f"\nЗапись {idx + 1}:")
#                 shoe_info = shoe.get_info()
#                 for key, value in shoe_info.items():
#                     print(f"{key}: {value}")
#             print("\n")

# display_all_shoes: Метод, который отображает информацию о всех парах обуви в библиотеке.
# Проверяет, пуст ли список shoes. 

# Если пуст, выводит соответствующее сообщение.
# Если не пуст, перебирает все объекты Shoe и выводит их информацию.










#     def save_to_file(self, filename="shoes_data.pkl"):
#         """Сохраняет всю библиотеку в файл."""
#         with open(filename, "wb") as file:
#             pickle.dump(self.shoes, file)
#         print(f"Данные сохранены в {filename}.")


# save_to_file: Метод, который сохраняет список обуви в файл с помощью pickle.
# Файл называется по умолчанию shoes_data.pkl.










#     def load_from_file(self, filename="shoes_data.pkl"):
#         """Загружает библиотеку из файла."""
#         try:
#             with open(filename, "rb") as file:
#                 self.shoes = pickle.load(file)
#             print(f"Данные загружены из {filename}.")
#         except FileNotFoundError:
#             print("Файл не найден, начинается новая сессия.")

# load_from_file: Метод для загрузки библиотеки из файла.

# Использует обработку исключений для обработки случаев,
# когда файл не существует, и выводит сообщение об этом.










# 4. Класс ShoeView

# class ShoeView:
#     @staticmethod
#     def display_shoe_info(shoe_info: dict):
#         """Отображает информацию об одной паре обуви."""
#         print("Shoe Information:")
#         for key, value in shoe_info.items():
#             print(f"{key}: {value}")

# class ShoeView: Определяет класс для представления информации об обуви.
# display_shoe_info: Статический метод, который принимает словарь с информацией об обуви и выводит его на экран.








# 5. Класс ShoeController

# class ShoeController:
#     def __init__(self, model: Shoe, view: ShoeView):
#         """Инициализирует контроллер с моделью и представлением."""
#         self.model = model  # Модель обуви
#         self.view = view    # Представление для отображения данных

# class ShoeController: Определяет класс контроллера,
# который управляет взаимодействием между моделью (обувь) и представлением (вывод информации).
# __init__: Инициализирует контроллер с моделью обуви и представлением.









#     def set_price(self, price: float):
#         """Изменяет цену обуви через модель."""
#         self.model.price = price

#     def set_size(self, size: int):
#         """Изменяет размер обуви через модель."""
#         self.model.size = size

# set_price и set_size: Методы для изменения цены и размера обуви через модель.









#     def display_shoe_info(self):
#         """Передает информацию модели в представление для отображения."""
#         shoe_info = self.model.get_info()
#         self.view.display_shoe_info(shoe_info)

# display_shoe_info: Метод, который получает информацию о обуви из модели и передает ее представлению для отображения.











# 6. Функция меню

# def menu(controller: ShoeController, library: ShoeLibrary):
#     while True:
#         print("\n1. Показать информацию об обуви")
#         print("2. Изменить цену")
#         print("3. Изменить размер")
#         print("4. Добавить обувь в библиотеку")
#         print("5. Показать всю обувь в библиотеке")
#         print("6. Сохранить данные")
#         print("7. Загрузить данные")
#         print("8. Выйти")

# menu: Функция, представляющая главное меню для взаимодействия с пользователем.
# Внутри цикла while True выводит доступные опции.











#         choice = input("Выберите опцию: ")

#         if choice == "1":
#             controller.display_shoe_info()

# Читает выбор пользователя и выполняет соответствующие действия в зависимости от выбора.










#         elif choice == "2":
#             try:
#                 new_price = float(input("Введите новую цену: "))
#                 controller.set_price(new_price)
#             except ValueError:
#                 print("Ошибка: цена должна быть числом.")

# Для опций изменения цены и размера добавлены блоки try-except,
# чтобы обработать возможные ошибки ввода.








#         elif choice == "4":
#             library.add_shoe(controller.model)
#             print("Обувь добавлена в библиотеку.")

# Позволяет добавлять текущую модель обуви в библиотеку.







#         elif choice == "6":
#             library.save_to_file()
#         elif choice == "7":
#             library.load_from_file()

# Сохраняет и загружает данные из файла.






#         elif choice == "8":
#             print("Выход...")
#             break
#         else:
#             print("Неверный выбор. Попробуйте снова.")

# Позволяет выходить из программы или обрабатывать неверные вводы.










# 7. Основной блок программы

# if __name__ == "__main__":
#     # Создаем модель обуви
#     shoe = Shoe(gender="Мужская", shoe_type="Кроссовки", color="Черный", price=100.0, manufacturer="Nike", size=42)

#     # Создаем представление
#     view = ShoeView()

#     # Создаем контроллер
#     controller = ShoeController(model=shoe, view=view)

#     # Создаем библиотеку для хранения всех записей
#     library = ShoeLibrary()

#     # Загружаем данные из файла
#     library.load_from_file()



# Основной блок программы:

# Создается объект Shoe с заданными параметрами.

# Создаются объекты ShoeView, ShoeController и ShoeLibrary.

# Загружаются данные из файла, если он существует.

# Запускается функция menu, позволяющая пользователю взаимодействовать с программой.









# Общая структура

# Модель (Shoe): Хранит данные об обуви.

# Представление (ShoeView): Отвечает за отображение данных пользователю.

# Контроллер (ShoeController): Управляет взаимодействием между моделью и представлением.

# Библиотека (ShoeLibrary): Хранит и управляет коллекцией обуви.

# Меню: Обеспечивает пользовательский интерфейс для взаимодействия с программой.

















# Задание 2
# Создайте класс Рецепт. Необходимо хранить следу-
# ющую информацию:
# ■ название рецепта;
# ■ автор рецепта;
# ■ тип рецепта (первое, второе блюдо и т.д.);
# ■ текстовое описание рецепта;
# ■ ссылка на видео с рецептом;
# ■ список ингредиентов;
# ■ название кухни (итальянская, французская, украин-
# ская и т.д.).
# Создайте необходимые методы для этого класса. Ре-
# ализуйте паттерн MVC для класса Рецепт и код для ис-
# пользования модели, контроллера и представления.











# class Recipe:
#     def __init__(self, title: str, author: str, recipe_type: str, description: str, video_link: str, ingredients: list, cuisine: str):
#         """Конструктор для создания объекта рецепта с начальными атрибутами."""
#         self.title = title                # Название рецепта
#         self.author = author              # Автор рецепта
#         self.recipe_type = recipe_type    # Тип рецепта (первое, второе блюдо и т.д.)
#         self.description = description     # Текстовое описание рецепта
#         self.video_link = video_link      # Ссылка на видео с рецептом
#         self.ingredients = ingredients     # Список ингредиентов
#         self.cuisine = cuisine             # Название кухни (итальянская, французская и т.д.)

#     def get_info(self):
#         """Метод для получения информации о рецепте в виде словаря."""
#         return {
#             "Title": self.title,
#             "Author": self.author,
#             "Recipe Type": self.recipe_type,
#             "Description": self.description,
#             "Video Link": self.video_link,
#             "Ingredients": self.ingredients,
#             "Cuisine": self.cuisine
#         }

#     def update_description(self, new_description: str):
#         """Метод для обновления описания рецепта."""
#         self.description = new_description

#     def update_video_link(self, new_video_link: str):
#         """Метод для обновления ссылки на видео рецепта."""
#         self.video_link = new_video_link

#     def add_ingredient(self, ingredient: str):
#         """Метод для добавления ингредиента в список."""
#         self.ingredients.append(ingredient)

#     def remove_ingredient(self, ingredient: str):
#         """Метод для удаления ингредиента из списка."""
#         if ingredient in self.ingredients:
#             self.ingredients.remove(ingredient)

# # Представление (View)
# class RecipeView:
#     @staticmethod
#     def display_recipe_info(recipe_info: dict):
#         """Отображает информацию о рецепте."""
#         print("Recipe Information:")
#         for key, value in recipe_info.items():
#             if isinstance(value, list):
#                 value = ', '.join(value)  # Преобразуем список в строку
#             print(f"{key}: {value}")

# # Контроллер (Controller)
# class RecipeController:
#     def __init__(self, model: Recipe, view: RecipeView):
#         """Инициализирует контроллер с моделью и представлением."""
#         self.model = model  # Модель рецепта
#         self.view = view    # Представление для отображения данных

#     def display_recipe_info(self):
#         """Передает информацию модели в представление для отображения."""
#         recipe_info = self.model.get_info()
#         self.view.display_recipe_info(recipe_info)

#     def update_description(self, new_description: str):
#         """Обновляет описание рецепта."""
#         self.model.update_description(new_description)

#     def update_video_link(self, new_video_link: str):
#         """Обновляет ссылку на видео рецепта."""
#         self.model.update_video_link(new_video_link)

#     def add_ingredient(self, ingredient: str):
#         """Добавляет ингредиент в рецепт."""
#         self.model.add_ingredient(ingredient)

#     def remove_ingredient(self, ingredient: str):
#         """Удаляет ингредиент из рецепта."""
#         self.model.remove_ingredient(ingredient)

# # Меню для взаимодействия с пользователем
# def menu(controller: RecipeController):
#     while True:
#         print("\n1. Показать информацию о рецепте")
#         print("2. Изменить описание рецепта")
#         print("3. Изменить ссылку на видео")
#         print("4. Добавить ингредиент")
#         print("5. Удалить ингредиент")
#         print("6. Выйти")

#         choice = input("Выберите опцию: ")

#         if choice == "1":
#             controller.display_recipe_info()
#         elif choice == "2":
#             new_description = input("Введите новое описание рецепта: ")
#             controller.update_description(new_description)
#             print("Описание обновлено.")
#         elif choice == "3":
#             new_video_link = input("Введите новую ссылку на видео: ")
#             controller.update_video_link(new_video_link)
#             print("Ссылка на видео обновлена.")
#         elif choice == "4":
#             new_ingredient = input("Введите ингредиент для добавления: ")
#             controller.add_ingredient(new_ingredient)
#             print(f"Ингредиент '{new_ingredient}' добавлен.")
#         elif choice == "5":
#             ingredient_to_remove = input("Введите ингредиент для удаления: ")
#             controller.remove_ingredient(ingredient_to_remove)
#             print(f"Ингредиент '{ingredient_to_remove}' удален.")
#         elif choice == "6":
#             print("Выход...")
#             break
#         else:
#             print("Неверный выбор. Попробуйте снова.")

# # Основной блок программы
# if __name__ == "__main__":
#     # Создаем модель рецепта
#     recipe = Recipe(
#         title="Паста Карбонара",
#         author="Итальянский повар",
#         recipe_type="Основное блюдо",
#         description="Классическая итальянская паста с беконом и сыром.",
#         video_link="https://example.com/recipe-video",
#         ingredients=["Паста", "Яйцо", "Пармезан", "Бекон", "Чёрный перец"],
#         cuisine="Итальянская"
#     )

#     # Создаем представление
#     view = RecipeView()

#     # Создаем контроллер
#     controller = RecipeController(model=recipe, view=view)

#     # Запускаем меню для взаимодействия
#     menu(controller)











# (1) Создание класса Recipe

# __init__ Метод: Этот метод является конструктором класса и вызывается при создании нового объекта.
# Он принимает параметры, такие как название рецепта, автор, тип, описание, ссылка на видео, список ингредиентов и кухня. 
# Эти параметры сохраняются как атрибуты объекта.

# def __init__(self, title: str, author: str, recipe_type: str, description: str, video_link: str, ingredients: list, cuisine: str):










# (2) Методы класса Recipe:

# get_info: Возвращает информацию о рецепте в виде словаря,
# что позволяет легко получать данные о рецепте.



# def get_info(self):
#     return {
#         "Title": self.title,
#         "Author": self.author,
#         ...
#     }

# update_description: Позволяет обновить описание рецепта.

# update_video_link: Позволяет обновить ссылку на видео.

# add_ingredient: Добавляет новый ингредиент в список.

# remove_ingredient: Удаляет указанный ингредиент из списка.









# (3) Создание класса RecipeView:

# Этот класс отвечает за отображение информации о рецепте.
# display_recipe_info: Статический метод, 
# который принимает словарь с информацией о рецепте и отображает его на экране.


# class RecipeView:
#     @staticmethod
#     def display_recipe_info(recipe_info: dict):
#         ...








# (4) Создание класса RecipeController:

# Контроллер связывает модель и представление.

# Он отвечает за обновление модели и отображение данных через представление.

# Методы:

# display_recipe_info: Отправляет информацию из модели в представление.

# Методы для обновления описания, видео и ингредиентов: Позволяют управлять данными в модели.








# (5) Функция menu:

# Эта функция создает текстовое меню для взаимодействия с пользователем.
# Она запрашивает пользователя о действиях, которые он хочет выполнить (например, показать информацию о рецепте, обновить описание и т.д.).

# В зависимости от выбора пользователя вызываются соответствующие методы контроллера.







# (6) Основной блок программы:

# Здесь создается экземпляр класса Recipe с начальными данными.
# Создаются экземпляры представления и контроллера.

# Вызывается функция menu, чтобы начать взаимодействие с пользователем.











# Код №2









# import pickle

# class Recipe:
#     def __init__(self, title: str, author: str, recipe_type: str, description: str, video_link: str, ingredients: list, cuisine: str):
#         """Конструктор для создания объекта рецепта с начальными атрибутами."""
#         self.title = title                # Название рецепта
#         self.author = author              # Автор рецепта
#         self.recipe_type = recipe_type    # Тип рецепта (первое, второе блюдо и т.д.)
#         self.description = description     # Текстовое описание рецепта
#         self.video_link = video_link      # Ссылка на видео с рецептом
#         self.ingredients = ingredients     # Список ингредиентов
#         self.cuisine = cuisine             # Название кухни (итальянская, французская и т.д.)

#     def get_info(self):
#         """Метод для получения информации о рецепте в виде словаря."""
#         return {
#             "Title": self.title,
#             "Author": self.author,
#             "Recipe Type": self.recipe_type,
#             "Description": self.description,
#             "Video Link": self.video_link,
#             "Ingredients": self.ingredients,
#             "Cuisine": self.cuisine
#         }

#     def update_description(self, new_description: str):
#         """Метод для обновления описания рецепта."""
#         self.description = new_description

#     def update_video_link(self, new_video_link: str):
#         """Метод для обновления ссылки на видео рецепта."""
#         self.video_link = new_video_link

#     def add_ingredient(self, ingredient: str):
#         """Метод для добавления ингредиента в список."""
#         self.ingredients.append(ingredient)

#     def remove_ingredient(self, ingredient: str):
#         """Метод для удаления ингредиента из списка."""
#         if ingredient in self.ingredients:
#             self.ingredients.remove(ingredient)

# class RecipeView:
#     @staticmethod
#     def display_recipe_info(recipe_info: dict):
#         """Отображает информацию о рецепте."""
#         print("Recipe Information:")
#         for key, value in recipe_info.items():
#             if isinstance(value, list):
#                 value = ', '.join(value)  # Преобразуем список в строку
#             print(f"{key}: {value}")

# class RecipeController:
#     def __init__(self, model: Recipe, view: RecipeView):
#         """Инициализирует контроллер с моделью и представлением."""
#         self.model = model  # Модель рецепта
#         self.view = view    # Представление для отображения данных

#     def display_recipe_info(self):
#         """Передает информацию модели в представление для отображения."""
#         recipe_info = self.model.get_info()
#         self.view.display_recipe_info(recipe_info)

#     def update_description(self, new_description: str):
#         """Обновляет описание рецепта."""
#         self.model.update_description(new_description)

#     def update_video_link(self, new_video_link: str):
#         """Обновляет ссылку на видео рецепта."""
#         self.model.update_video_link(new_video_link)

#     def add_ingredient(self, ingredient: str):
#         """Добавляет ингредиент в рецепт."""
#         self.model.add_ingredient(ingredient)

#     def remove_ingredient(self, ingredient: str):
#         """Удаляет ингредиент из рецепта."""
#         self.model.remove_ingredient(ingredient)

#     def save_to_file(self, filename="recipe_data.pkl"):
#         """Сохраняет модель рецепта в файл."""
#         with open(filename, "wb") as file:
#             pickle.dump(self.model, file)
#         print(f"Данные сохранены в {filename}.")

#     def load_from_file(self, filename="recipe_data.pkl"):
#         """Загружает модель рецепта из файла."""
#         try:
#             with open(filename, "rb") as file:
#                 self.model = pickle.load(file)
#             print(f"Данные загружены из {filename}.")
#         except FileNotFoundError:
#             print("Файл не найден, начинается новая сессия.")

# def menu(controller: RecipeController):
#     while True:
#         print("\n1. Показать информацию о рецепте")
#         print("2. Изменить описание рецепта")
#         print("3. Изменить ссылку на видео")
#         print("4. Добавить ингредиент")
#         print("5. Удалить ингредиент")
#         print("6. Сохранить данные")
#         print("7. Загрузить данные")
#         print("8. Выйти")

#         choice = input("Выберите опцию: ")

#         if choice == "1":
#             controller.display_recipe_info()
#         elif choice == "2":
#             new_description = input("Введите новое описание рецепта: ")
#             controller.update_description(new_description)
#             print("Описание обновлено.")
#         elif choice == "3":
#             new_video_link = input("Введите новую ссылку на видео: ")
#             controller.update_video_link(new_video_link)
#             print("Ссылка на видео обновлена.")
#         elif choice == "4":
#             new_ingredient = input("Введите ингредиент для добавления: ")
#             controller.add_ingredient(new_ingredient)
#             print(f"Ингредиент '{new_ingredient}' добавлен.")
#         elif choice == "5":
#             ingredient_to_remove = input("Введите ингредиент для удаления: ")
#             controller.remove_ingredient(ingredient_to_remove)
#             print(f"Ингредиент '{ingredient_to_remove}' удален.")
#         elif choice == "6":
#             controller.save_to_file()
#         elif choice == "7":
#             controller.load_from_file()
#         elif choice == "8":
#             print("Выход...")
#             break
#         else:
#             print("Неверный выбор. Попробуйте снова.")

# if __name__ == "__main__":
#     # Создаем модель рецепта
#     recipe = Recipe(
#         title="Паста Карбонара",
#         author="Итальянский повар",
#         recipe_type="Основное блюдо",
#         description="Классическая итальянская паста с беконом и сыром.",
#         video_link="https://example.com/recipe-video",
#         ingredients=["Паста", "Яйцо", "Пармезан", "Бекон", "Чёрный перец"],
#         cuisine="Итальянская"
#     )

#     # Создаем представление
#     view = RecipeView()

#     # Создаем контроллер
#     controller = RecipeController(model=recipe, view=view)

#     # Запускаем меню для взаимодействия
#     menu(controller)









# (1) Импортируем библиотеку pickle

# Библиотека pickle используется для сериализации и десериализации объектов Python.
# Она позволяет сохранять объекты в файл и загружать их обратно.










# (2) Создание класса Recipe

# __init__ Метод: Конструктор класса, 
# который принимает различные параметры, чтобы создать объект рецепта.

# def __init__(self, title: str, author: str, recipe_type: str, description: str, video_link: str, ingredients: list, cuisine: str):

# Атрибуты:
# title: Название рецепта.

# author: Автор рецепта.

# recipe_type: Тип рецепта (например, первое, второе блюдо).

# description: Описание рецепта.

# video_link: Ссылка на видео.

# ingredients: Список ингредиентов.

# cuisine: Название кухни.

# Методы:
# get_info(): Возвращает информацию о рецепте в виде словаря, что позволяет легко получать данные о рецепте.

# update_description(new_description): Обновляет описание рецепта.

# update_video_link(new_video_link): Обновляет ссылку на видео.

# add_ingredient(ingredient): Добавляет новый ингредиент в список.

# remove_ingredient(ingredient): Удаляет указанный ингредиент из списка, если он существует.









# (3) Создание класса RecipeView

# Этот класс отвечает за отображение информации о рецепте.
# display_recipe_info(recipe_info): Статический метод, который принимает словарь с информацией о рецепте и выводит его на экран.

# class RecipeView:
#     @staticmethod
#     def display_recipe_info(recipe_info: dict):
#         ...






# (4) Создание класса RecipeController

# Контроллер связывает модель и представление.

# Он отвечает за обновление модели и отображение данных через представление.
# Методы:
# display_recipe_info(): Передает информацию из модели в представление.

# update_description(new_description): Обновляет описание рецепта.

# update_video_link(new_video_link): Обновляет ссылку на видео рецепта.

# add_ingredient(ingredient): Добавляет ингредиент в рецепт.

# remove_ingredient(ingredient): Удаляет ингредиент из рецепта.

# save_to_file(filename): Сохраняет модель рецепта в файл.

# load_from_file(filename): Загружает модель рецепта из файла.






# (5) Функция menu

# Эта функция создает текстовое меню для взаимодействия с пользователем.

# Она запрашивает пользователя о действиях, которые он хочет выполнить (например, показать информацию о рецепте, обновить описание, сохранить данные и т.д.).
# В зависимости от выбора пользователя вызываются соответствующие методы контроллера.








# (6) Основной блок программы

# Здесь создается экземпляр класса Recipe с начальными данными.

# Создаются экземпляры представления и контроллера.

# Вызывается функция menu, чтобы начать взаимодействие с пользователем.









#  Модуль 14. Solid
#  Тема: Solid 











# 1. S - Принцип единственной ответственности (Single Responsibility Principle, SRP)

# Понятие:
# Каждый класс или модуль должен иметь только одну причину для изменения, то есть выполнять только одну задачу.

# Пример:

# Представьте класс, который занимается обработкой данных, их выводом и записью в файл. 

# Это сразу несколько обязанностей.

# Если что-то изменится в способе обработки данных или записи их в файл, вам придётся менять этот класс, что может привести к ошибкам.


# class Report:
#     def __init__(self, data):
#         self.data = data

#     def calculate(self):
#         # Логика расчётов
#         pass

#     def print_report(self):
#         # Вывод отчета на экран
#         print(f"Отчет: {self.data}")

#     def save_to_file(self):
#         # Сохранение отчета в файл
#         with open('report.txt', 'w') as file:
#             file.write(str(self.data))


# Здесь класс Report отвечает за расчёты, вывод отчёта и его сохранение. Если изменится способ сохранения данных (например, захотите сохранять в базу данных), придётся изменить этот класс.

# Как должно быть:
# Нужно разделить эти обязанности на разные классы:


# class Report:
#     def __init__(self, data):
#         self.data = data

#     def calculate(self):
#         # Логика расчётов
#         pass

# class ReportPrinter:
#     @staticmethod
#     def print_report(report):
#         print(f"Отчет: {report.data}")

# class ReportSaver:
#     @staticmethod
#     def save_to_file(report):
#         with open('report.txt', 'w') as file:
#             file.write(str(report.data))


# Теперь у нас три класса с чёткими обязанностями: один отвечает за расчёты, другой за вывод на экран, третий — за сохранение в файл.



















# 2. O - Принцип открытости/закрытости (Open-Closed Principle, OCP)
# Понятие:
# Классы должны быть открыты для расширения, но закрыты для модификации. Это значит, что нужно проектировать систему так, чтобы можно было добавлять новые функции, не изменяя существующий код.

# Пример:
# Представьте, что у вас есть система оплаты, которая принимает только наличные, но позже вы хотите добавить оплату картой. Если вы измените существующий код, это может привести к ошибкам или усложнению.


# Нарушение OCP:


# class PaymentProcessor:
#     def pay(self, method, amount):
#         if method == "cash":
#             print(f"Оплачено наличными: {amount}")
#         elif method == "card":
#             print(f"Оплачено картой: {amount}")


# Если вам нужно добавить новый способ оплаты, например через PayPal, придётся менять код.

# Как должно быть:
# Используйте наследование или полиморфизм, чтобы расширять поведение классов, не изменяя исходный код:


# class PaymentProcessor:
#     def pay(self, amount):
#         raise NotImplementedError

# class CashPayment(PaymentProcessor):
#     def pay(self, amount):
#         print(f"Оплачено наличными: {amount}")

# class CardPayment(PaymentProcessor):
#     def pay(self, amount):
#         print(f"Оплачено картой: {amount}")


# Теперь, если нужно добавить новый метод оплаты, можно просто создать новый класс, не меняя существующие.



















# 3. L - Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP)
# Понятие:
# Объекты в программе должны заменяться экземплярами их подклассов без изменения корректности программы. Другими словами, если класс B является подклассом A, то объекты B должны корректно заменять объекты A.

# Пример:
# Представьте, что у вас есть базовый класс Shape (форма) и два подкласса: Rectangle (прямоугольник) и Square (квадрат). Согласно LSP, квадрат должен вести себя как прямоугольник.


# Нарушение LSP:

# class Rectangle:
#     def __init__(self, width, height):
#         self.width = width
#         self.height = height

#     def set_width(self, width):
#         self.width = width

#     def set_height(self, height):
#         self.height = height

# class Square(Rectangle):
#     def set_width(self, width):
#         self.width = width
#         self.height = width  # Нарушение LSP

#     def set_height(self, height):
#         self.width = height
#         self.height = height  # Нарушение LSP


# Здесь подкласс Square нарушает поведение базового класса, потому что ширина и высота у него всегда одинаковы. Если этот класс использовать как прямоугольник, логика сломается.

# Как должно быть:
# Не пытайтесь вписать поведение, которое кардинально отличается от базового класса. Лучше разделить логику:

# class Shape:
#     def area(self):
#         raise NotImplementedError

# class Rectangle(Shape):
#     def __init__(self, width, height):
#         self.width = width
#         self.height = height

#     def area(self):
#         return self.width * self.height

# class Square(Shape):
#     def __init__(self, side):
#         self.side = side

#     def area(self):
#         return self.side * self.side

# Теперь оба класса имеют корректную и независимую реализацию, не нарушая принцип LSP.
















# 4. I - Принцип разделения интерфейса (Interface Segregation Principle, ISP)
# Понятие:
# Клиенты не должны зависеть от методов, которые они не используют. Другими словами, не создавайте слишком большие интерфейсы, которые обязывают классы реализовывать ненужные методы.

# Пример:
# Представьте интерфейс для многофункционального устройства, которое умеет сканировать, печатать и факсить. Если есть принтер, который не поддерживает функцию факса, но должен её реализовывать, это нарушение ISP.


# Нарушение ISP:

# class MultiFunctionDevice:
#     def print(self):
#         pass

#     def scan(self):
#         pass

#     def fax(self):
#         pass

# class SimplePrinter(MultiFunctionDevice):
#     def print(self):
#         print("Печать")

#     def scan(self):
#         pass  # Этот метод не нужен

#     def fax(self):
#         pass  # Этот метод тоже не нужен

# Здесь SimplePrinter вынужден реализовать ненужные методы, хотя он не поддерживает функции сканирования и факса.

# Как должно быть:
# Разделите интерфейсы на более мелкие:

# class Printer:
#     def print(self):
#         raise NotImplementedError

# class Scanner:
#     def scan(self):
#         raise NotImplementedError

# class SimplePrinter(Printer):
#     def print(self):
#         print("Печать")

# Теперь классы реализуют только то, что им нужно.












# 5. D - Принцип инверсии зависимостей (Dependency Inversion Principle, DIP)
# Понятие:
# Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей, а детали должны зависеть от абстракций.

# Пример:
# Представьте, что класс использует конкретную реализацию другого класса. Если этот класс изменится, то придётся менять и основной код.


# Нарушение DIP:

# class Keyboard:
#     def type(self):
#         print("Набор текста")

# class Computer:
#     def __init__(self):
#         self.keyboard = Keyboard()

#     def use_keyboard(self):
#         self.keyboard.type()


# Если в будущем вам понадобится подключить другую клавиатуру (например, виртуальную), придётся менять код класса Computer.

# Как должно быть:
# Используйте абстракции (интерфейсы или базовые классы):

# class IKeyboard:
#     def type(self):
#         raise NotImplementedError

# class MechanicalKeyboard(IKeyboard):
#     def type(self):
#         print("Набор текста на механической клавиатуре")

# class Computer:
#     def __init__(self, keyboard: IKeyboard):
#         self.keyboard = keyboard

#     def use_keyboard(self):
#         self.keyboard.type()

# Теперь, если нужно будет использовать другую клавиатуру, достаточно будет реализовать новый класс, который наследуется от IKeyboard, без изменений в классе Computer.



# Вывод:
# Принципы SOLID помогают структурировать код, делая его легко поддерживаемым и расширяемым. Применение этих принципов на практике требует опыта, но они значительно










# SOLID — это пять основных принципов объектно-ориентированного программирования, предложенные Робертом Мартином. Они помогают разработчикам создавать гибкие, поддерживаемые и легко расширяемые системы, избегая излишней сложности и проблем с внесением изменений. Давайте разберём каждый принцип отдельно.

# 1. S - Принцип единственной ответственности (Single Responsibility Principle, SRP)
# Суть: Класс должен иметь только одну причину для изменения, т.е. выполнять одну единственную задачу. Это означает, что каждая сущность (класс, модуль, функция) должна быть ответственна только за одну вещь.

# Цель: Основная цель этого принципа — разделение обязанностей. Если класс выполняет множество разных задач, то его сложно поддерживать и изменять, так как любое изменение может затронуть сразу несколько аспектов.

# Почему это важно: Классы, которые нарушают этот принцип, становятся слишком "многофункциональными", что приводит к большему количеству ошибок, сложностям в тестировании и поддержке кода. Разделение обязанностей делает код проще для понимания, а также позволяет повторно использовать его в других частях программы.












# 2. O - Принцип открытости/закрытости (Open-Closed Principle, OCP)
# Суть: Программные сущности (классы, модули, функции) должны быть открыты для расширения, но закрыты для модификации. Это значит, что мы можем расширять функциональность системы, не изменяя уже существующий код.

# Цель: Принцип помогает снизить риск внесения ошибок при изменениях, так как старый код не нужно изменять. Вместо этого добавляются новые классы или модули, которые могут быть интегрированы в систему через полиморфизм или другие методы расширения.

# Почему это важно: Когда система растёт, внесение изменений в уже существующий код увеличивает риск ошибок. Принцип OCP помогает минимизировать изменения и делает код более устойчивым к масштабированию.













# 3. L - Принцип подстановки Лисков (Liskov Substitution Principle, LSP)
# Суть: Объекты подклассов должны быть заменяемыми объектами их базовых классов без нарушения корректности программы. Это означает, что подклассы должны дополнять, а не изменять поведение базовых классов.

# Цель: Цель этого принципа — обеспечение совместимости между базовыми и производными классами. Подклассы должны полностью сохранять функциональность и контракты базовых классов.

# Почему это важно: Нарушение LSP приводит к тому, что использование полиморфизма становится опасным, так как программы, которые рассчитывают на поведение базовых классов, могут не работать правильно при подстановке подклассов. Это делает систему более хрупкой и сложной для поддержки.














# 4. I - Принцип разделения интерфейса (Interface Segregation Principle, ISP)
# Суть: Клиенты не должны зависеть от интерфейсов, которые они не используют. Это означает, что лучше создавать специализированные, маленькие интерфейсы, чем один большой интерфейс, который вынуждает реализовывать ненужные методы.

# Цель: Принцип ISP направлен на то, чтобы клиенты имели дело только с той функциональностью, которая им действительно нужна, без избыточности. Это делает интерфейсы проще для понимания и поддержания, а также позволяет избегать ненужных зависимостей.

# Почему это важно: Когда классы вынуждены реализовывать методы, которые им не нужны, это создаёт дополнительную сложность и делает код запутанным. Разделение интерфейсов на более узкие и специфичные упрощает проектирование системы и улучшает её гибкость.














# 5. D - Принцип инверсии зависимостей (Dependency Inversion Principle, DIP)
# Суть: Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей, детали должны зависеть от абстракций.

# Цель: DIP призван минимизировать жёсткие зависимости между модулями, делая систему более гибкой и готовой к изменениям. В идеале, классы высокого уровня должны работать через интерфейсы или абстракции, чтобы изменения в модулях низкого уровня не влияли на их работу.

# Почему это важно: Принцип инверсии зависимостей позволяет сделать систему более модульной, облегчая внесение изменений и тестирование. Когда классы высокого уровня напрямую зависят от низкоуровневых деталей, это делает систему менее гибкой, более сложной и увеличивает риск ошибок при изменении кода.

# Итог
# Принципы SOLID помогают разработчикам писать код, который легче понимать, поддерживать и масштабировать. Их соблюдение снижает сложность системы, улучшает её гибкость и делает внесение изменений безопасным. Основная идея этих принципов — обеспечить лучшее разделение обязанностей, сделать код более модульным и сократить количество жёстких зависимостей, что особенно важно при работе над большими и долгосрочными проектами.









# Ключевые выводы:

# SRP — делай одну задачу на один класс.
# OCP — расширяй, не изменяя.
# LSP — подклассы должны полностью соответствовать своим базовым классам.
# ISP — разбивай интерфейсы на более мелкие и специфичные.
# DIP — зависимости должны строиться вокруг абстракций, а не конкретных реализаций.
# Эти принципы помогают избежать создания «монолитного» кода и обеспечивают возможность эволюционного развития приложения, что в долгосрочной перспективе улучшает качество и стабильность программного обеспечения.

















# Задание
# Создайте приложение для эмуляции работа киоска
# по продаже хот-догов. Приложение должно иметь сле-
# дующую функциональность:

# 1 Пользователь может выбрать из трёх стандартных
# рецептов хот-дога или создать свой рецепт.

# 2 Пользователь может выбирать добавлять ли майонез,
# горчицу, кетчуп, топпинги (сладкий лук, халапеньо,
# чили, соленный огурец и т.д.).

# 3 Информацию о заказанном хот-доге нужно отобра-
# жать на экран и сохранять в файл.

# 4 Если пользователь заказывает от трёх хот-догов нужно
# предусмотреть скидку. Скидка зависит от количества
# хот-догов.

# 5 Расчет может производиться, как наличными, так и
# картой.

# 6 Необходимо иметь возможность просмотреть коли-
# чество проданных хот-догов, выручку, прибыль.

# 7 Необходимо иметь возможность просмотреть инфор-
# мацию о наличии компонентов для создания хот-дога.

# 8 Если компоненты для создания хот-догов заканчи-
# ваются нужно вывести информационное сообщение
# о тех компонентах, которые требуется приобрести.

# 9 Классы приложения должны быть построены с уче-
# том принципов SOLID и паттернов проектирования.












#  Структура приложения
# Приложение будет построено с использованием нескольких классов:

# HotDog — для описания хот-дога (его ингредиентов и настроек).

# Order — для управления заказом, включая выбор рецептов, добавление ингредиентов, скидки.

# Payment — для обработки разных типов платежей.

# Kiosk — для работы киоска, управления ингредиентами, продажами, и выполнения всех операций.

# Inventory — для отслеживания доступности ингредиентов и их пополнения.

# DiscountStrategy — реализация паттерна "Стратегия" для работы со скидками.






# class HotDog:
#     def __init__(self, name, base_price=100):
#         self.name = name
#         self.base_price = base_price
#         self.ingredients = []

#     def add_ingredient(self, ingredient, price):
#         self.ingredients.append(ingredient)
#         self.base_price += price

#     def __str__(self):
#         return f"{self.name} с ингредиентами: {', '.join(self.ingredients)}. Цена: {self.base_price}."

# # Класс для заказа
# class Order:
#     def __init__(self):
#         self.hotdogs = []
#         self.total_price = 0

#     def add_hotdog(self, hotdog):
#         self.hotdogs.append(hotdog)
#         self.total_price += hotdog.base_price

#     def apply_discount(self, discount_strategy):
#         if len(self.hotdogs) >= 3:
#             discount = discount_strategy.calculate_discount(self.total_price)
#             self.total_price -= discount

#     def __str__(self):
#         return f"Заказ: {[str(hotdog) for hotdog in self.hotdogs]}. Итоговая цена: {self.total_price}"

# # Стратегия скидок
# class DiscountStrategy:
#     def calculate_discount(self, total_price):
#         # Пример: скидка 10% если 3 и более хот-догов
#         return total_price * 0.1

# # Класс для платежей
# class Payment:
#     def __init__(self, method):
#         self.method = method

#     def pay(self, amount):
#         if self.method == "cash":
#             print(f"Оплачено наличными: {amount}")
#         elif self.method == "card":
#             print(f"Оплачено картой: {amount}")

# # Класс для управления ингредиентами
# class Inventory:
#     def __init__(self):
#         self.ingredients = {
#             "майонез": 5,
#             "горчица": 5,
#             "кетчуп": 5,
#             "сладкий лук": 5,
#             "халапеньо": 5,
#             "чили": 5,
#             "соленный огурец": 5
#         }

#     def check_availability(self, ingredient):
#         return self.ingredients.get(ingredient, 0) > 0

#     def reduce_stock(self, ingredient):
#         if self.check_availability(ingredient):
#             self.ingredients[ingredient] -= 1
#         else:
#             print(f"Ингредиент {ingredient} закончился!")

# # Класс для киоска
# class Kiosk:
#     def __init__(self):
#         self.inventory = Inventory()
#         self.sales = 0
#         self.profit = 0
#         self.discount_strategy = DiscountStrategy()

#     def make_hotdog(self, name):
#         hotdog = HotDog(name)
#         return hotdog

#     def order_hotdog(self, order):
#         order.apply_discount(self.discount_strategy)
#         print(order)
#         self.sales += order.total_price
#         self.profit += order.total_price - self.calculate_cost(order)

#     def calculate_cost(self, order):
#         # Простая модель, в реальности стоимость производства выше
#         return order.total_price * 0.3

#     def check_inventory(self):
#         for ingredient, count in self.inventory.ingredients.items():
#             if count < 3:
#                 print(f"Ингредиент {ingredient} почти закончился! Осталось {count} штук.")

#     def summary(self):
#         print(f"Продано хот-догов на сумму: {self.sales}")
#         print(f"Прибыль: {self.profit}")

# # Новое меню выбора ингредиентов и хот-догов
# def choose_ingredients(hotdog, kiosk):
#     ingredients = {
#         "майонез": 5,
#         "горчица": 5,
#         "кетчуп": 5,
#         "сладкий лук": 7,
#         "халапеньо": 7,
#         "чили": 10,
#         "соленный огурец": 8
#     }

#     print("\nДоступные ингредиенты для добавления:")
#     for i, (ingredient, price) in enumerate(ingredients.items(), start=1):
#         print(f"{i}. {ingredient} - {price} рублей")

#     while True:
#         choice = input("\nВыберите номер ингредиента (или 'q' для выхода): ")
#         if choice == 'q':
#             break
#         elif choice.isdigit() and int(choice) in range(1, len(ingredients) + 1):
#             ingredient = list(ingredients.keys())[int(choice) - 1]
#             price = ingredients[ingredient]
#             if kiosk.inventory.check_availability(ingredient):
#                 hotdog.add_ingredient(ingredient, price)
#                 kiosk.inventory.reduce_stock(ingredient)
#                 print(f"Добавлен {ingredient} за {price} рублей")
#             else:
#                 print(f"Ингредиент {ingredient} закончился!")
#         else:
#             print("Неверный ввод, попробуйте снова.")

# def main_menu():
#     kiosk = Kiosk()

#     while True:
#         print("\n1. Заказать хот-дог")
#         print("2. Проверить инвентарь")
#         print("3. Просмотреть выручку и прибыль")
#         print("4. Выход")

#         choice = input("Выберите опцию: ")

#         if choice == '1':
#             order = Order()

#             # Предложение выбора хот-дога
#             print("\nВыберите хот-дог:")
#             print("1. Классический (100 рублей)")
#             print("2. Вегетарианский (120 рублей)")
#             print("3. Острая версия (130 рублей)")
#             hotdog_choice = input("\nВведите номер хот-дога: ")

#             if hotdog_choice == '1':
#                 hotdog = kiosk.make_hotdog("Классический")
#             elif hotdog_choice == '2':
#                 hotdog = kiosk.make_hotdog("Вегетарианский")
#             elif hotdog_choice == '3':
#                 hotdog = kiosk.make_hotdog("Острая версия")
#             else:
#                 print("Неверный выбор.")
#                 continue

#             # Добавление ингредиентов вручную
#             choose_ingredients(hotdog, kiosk)

#             order.add_hotdog(hotdog)
#             kiosk.order_hotdog(order)

#         elif choice == '2':
#             kiosk.check_inventory()

#         elif choice == '3':
#             kiosk.summary()

#         elif choice == '4':
#             break

# if __name__ == "__main__":
#     main_menu()





# Класс HotDog:

# Описание: Моделирует объект хот-дога.
# Методы и атрибуты:


# __init__(self, name, base_price=100): Конструктор, который принимает название хот-дога и его базовую цену. 

# Инициализирует список ingredients для хранения добавленных ингредиентов.

# add_ingredient(self, ingredient, price): Этот метод добавляет ингредиент в список ingredients и увеличивает цену на стоимость этого ингредиента.

# __str__(self): Этот метод возвращает строковое представление хот-дога с его ингредиентами и общей ценой. 
# Это удобно для отображения информации пользователю.









# Класс Order:

# Описание: Представляет заказ, который может содержать несколько хот-догов.
# Методы и атрибуты:


# __init__(self): Конструктор, который инициализирует список hotdogs для хранения хот-догов в заказе и переменную total_price для общей стоимости заказа.

# add_hotdog(self, hotdog): Добавляет хот-дог в заказ и увеличивает общую стоимость на цену этого хот-дога.

# apply_discount(self, discount_strategy): Применяет скидку, если в заказе 3 и более хот-догов, используя стратегию скидок.

# __str__(self): Возвращает строковое представление заказа с информацией обо всех хот-догах и итоговой ценой.







# Класс DiscountStrategy:

# Описание: Стратегия расчета скидок.
# Методы:


# calculate_discount(self, total_price): Вычисляет скидку на основе общей стоимости заказа. 
# Пример: скидка 10%, если заказано 3 или более хот-догов.







# Класс Payment:

# Описание: Моделирует процесс оплаты.
# Методы и атрибуты:


# __init__(self, method): Конструктор, который принимает метод оплаты: наличные или карта.
# pay(self, amount): Выполняет оплату, выводя сообщение о выбранном методе оплаты и сумме.








# Класс Inventory:

# Описание: Управляет запасами ингредиентов.
# Методы и атрибуты:


# __init__(self): Инициализирует словарь ingredients, где каждому ингредиенту соответствует его количество на складе.

# check_availability(self, ingredient): Проверяет наличие ингредиента в достаточном количестве.

# reduce_stock(self, ingredient): Уменьшает количество ингредиента на складе, если он доступен.

# Если ингредиент закончился, выводится предупреждение.







# Класс Kiosk:

# Описание: Моделирует работу киоска.
# Методы и атрибуты:


# __init__(self): Конструктор, инициализирует объект inventory для работы с запасами, переменные sales для выручки,
# profit для прибыли и объект discount_strategy для расчета скидок.

# make_hotdog(self, name): Создает новый объект HotDog с заданным именем.

# order_hotdog(self, order): Оформляет заказ, применяет скидки и добавляет выручку. 
# Вычисляет прибыль по формуле: цена заказа минус 30% затрат.

# calculate_cost(self, order): Возвращает стоимость производства заказа.
# В этом примере она рассчитывается как 30% от стоимости заказа.

# check_inventory(self): Проверяет запасы ингредиентов. 
# Если чего-то осталось меньше 3 штук, выводится предупреждение.
# summary(self): Выводит сумму выручки и прибыли.








# Взаимодействие с пользователем:
# Функция choose_ingredients(hotdog, kiosk):

# Позволяет пользователю добавлять ингредиенты к хот-догу.

# Ингредиенты выбираются по номеру из списка, а их стоимость добавляется к базовой цене хот-дога.

# Проверяется наличие ингредиентов с помощью метода check_availability из класса Inventory.

# Если ингредиент доступен, он добавляется в хот-дог, и его запас уменьшается через метод reduce_stock. 
# Если его нет, выводится сообщение о его отсутствии.






# Функция main_menu():
# Главное меню программы.

# Пункты меню:

# 1. Заказать хот-дог: Пользователь выбирает один из стандартных видов хот-догов и вручную добавляет ингредиенты через функцию choose_ingredients().
# После этого создается заказ через объект Order, и хот-дог добавляется в заказ. Заказ оформляется с применением скидки (если нужно).

# 2. Проверить инвентарь: Выводится информация о наличии ингредиентов в киоске с помощью метода check_inventory().

# 3. Просмотреть выручку и прибыль: Показывает общую выручку и прибыль с помощью метода summary().

# 4. Выход: Завершает программу.









# Как это работает:
# Когда пользователь выбирает заказать хот-дог:

# Программа предлагает выбрать один из трех видов хот-догов.
# Затем пользователь вручную добавляет ингредиенты.
# После добавления ингредиентов создается заказ, который оформляется с учетом скидки, если заказано 3 или более хот-догов.
# Информация о заказе выводится на экран, и стоимость добавляется в общую выручку и прибыль киоска.
# Проверка инвентаря:

# При выборе пункта проверки инвентаря программа просматривает текущие запасы ингредиентов. 
# Если чего-то осталось меньше трех, выводится предупреждение.
# Просмотр выручки и прибыли:

# Когда пользователь выбирает этот пункт, программа выводит общую сумму проданных хот-догов и прибыль киоска.













#  Модуль 14. Структуры данных
#  Тема: Структуры данных. Часть 1 











# Структуры данных в Python: Полное Понятие и Конспект
# Структуры данных — это способы организации и хранения данных, чтобы к ним можно было легко обращаться и эффективно их использовать. В программировании выбор правильной структуры данных помогает ускорить работу программы и сделать код более читабельным. В Python структуры данных встроены в язык и обеспечивают высокую гибкость.

# Основные типы структур данных в Python:
# Список (List)
# Кортеж (Tuple)
# Множество (Set)
# Словарь (Dictionary)












# 1. Список (List)
# Список — это изменяемая (mutable) структура данных, которая позволяет хранить последовательность элементов в одном объекте. Элементы могут быть любого типа, а сам список поддерживает индексацию и срезы.

# Списки поддерживают добавление, удаление, изменение элементов.
# Индексация начинается с нуля (0), то есть первый элемент имеет индекс 0.
# Характеристики списка:

# Изменяемость: можно добавлять и удалять элементы.
# Упорядоченность: элементы в списке сохраняют порядок, в котором были добавлены.
# Поддержка дублирования: можно хранить одинаковые элементы.
# Списки позволяют хранить любые типы данных — от строк до чисел или даже других списков.













# 2. Кортеж (Tuple)
# Кортеж — это неизменяемая (immutable) структура данных. В отличие от списка, элементы кортежа после создания изменить нельзя.




# Характеристики кортежа:
# Неизменяемость: как только кортеж создан, изменить его нельзя.
# Упорядоченность: элементы в кортеже сохраняют порядок.
# Поддержка дублирования: как и списки, кортежи могут содержать одинаковые элементы.
# Кортежи часто используются для данных, которые должны оставаться неизменными, таких как координаты или константы.









# 3. Множество (Set)
# Множество — это неупорядоченная структура данных, которая хранит только уникальные элементы. В Python множества поддерживают такие математические операции, как объединение, пересечение и разность.




# Характеристики множества:
# Неупорядоченность: элементы множества не имеют индексов, и порядок их добавления не имеет значения.
# Уникальность: каждый элемент может появиться в множестве только один раз.
# Изменяемость: можно добавлять и удалять элементы, хотя существует и неизменяемый тип множеств — frozenset.
# Множества особенно полезны, когда нужно работать с уникальными элементами, например, для удаления дубликатов из списка.









# 4. Словарь (Dictionary)
# Словарь — это структура данных, которая хранит пары ключ-значение. Каждый ключ должен быть уникальным, а значение может быть любого типа.




# Характеристики словаря:
# Неупорядоченность до Python 3.7 (в версии 3.7 и выше порядок элементов сохраняется).
# Ключи должны быть уникальными и неизменяемыми (строки, числа или кортежи).
# Значения могут быть любыми объектами Python, включая списки и другие словари.
# Словари позволяют быстро искать данные по ключам, что делает их важными для хранения ассоциированных данных, таких как телефонные книги или настройки приложений.






# Важные аспекты работы со структурами данных:
# Изменяемость — это возможность изменять данные внутри структуры. Например, списки изменяемы, а кортежи нет.
# Время доступа — у разных структур данных разные скорости доступа к элементам. Например, доступ к элементам списка или кортежа происходит быстро благодаря индексации, а в словарях — по ключам.
# Операции над структурами — каждая структура поддерживает определённые операции. Например, в списках можно сортировать элементы, а во множествах — проводить математические операции вроде объединения или пересечения.






# Когда использовать конкретные структуры данных:
# Список используется, когда нужен динамический массив, который можно изменять. Это одна из самых гибких структур.
# Кортеж полезен, когда данные не должны изменяться после их создания. Пример — координаты или параметры функции.
# Множество подходит для работы с уникальными элементами и для математических операций с множествами.
# Словарь идеально подходит, когда необходимо сопоставить ключи и значения, например, для хранения конфигураций, кэширования или связей.



# Способы работы со структурами данных:
# Итерации: Все структуры поддерживают операции итерации. Списки, кортежи и множества можно перебирать с помощью циклов.
# Компрехеншены (comprehensions): Это специальные конструкции для создания списков, словарей или множеств из других коллекций на основе заданного условия. 
# Они позволяют создавать структуры данных более эффективно и компактно.
















# Задание 1
# Пользователь вводит с клавиатуры набор чисел. По-
# лученные числа необходимо сохранить в список (тип
# списка нужно выбрать в зависимости от поставленной
# ниже задачи). После чего нужно показать меню, в котором
# предложить пользователю набор пунктов:
# 1 Добавить новое число в список (если такое число су-
# ществует в списке, нужно вывести сообщение поль-
# зователю об этом, без добавления числа).
# 2 Удалить все вхождения числа из списка (пользователь
# вводит с клавиатуры число для удаления).
# 3 Показать содержимое списка (в зависимости от вы-
# бора пользователя список нужно показать с начала
# или с конца).
# 4 Проверить есть ли значение в списке.
# 5 Заменить значение в списке (пользователь опреде-
# ляет заменить ли только первое вхождение или все
# вхождения).
# В зависимости от выбора пользователя выполняется
# действие, после чего меню отображается снова.











# def print_menu():
#     print("\nМеню:")
#     print("1. Добавить новое число в список")
#     print("2. Удалить все вхождения числа из списка")
#     print("3. Показать содержимое списка")
#     print("4. Проверить есть ли значение в списке")
#     print("5. Заменить значение в списке")
#     print("6. Выход")

# def add_number(numbers_list):
#     try:
#         num = int(input("Введите число для добавления: "))
#         if num in numbers_list:
#             print(f"Число {num} уже есть в списке!")
#         else:
#             numbers_list.append(num)
#             print(f"Число {num} добавлено в список.")
#     except ValueError:
#         print("Введите корректное число.")

# def remove_number(numbers_list):
#     try:
#         num = int(input("Введите число для удаления: "))
#         numbers_list[:] = [x for x in numbers_list if x != num]
#         print(f"Все вхождения числа {num} удалены.")
#     except ValueError:
#         print("Введите корректное число.")

# def show_list(numbers_list):
#     choice = input("Показать с начала или с конца? (введите 'начало' или 'конец'): ").strip().lower()
#     if choice == "начало":
#         print("Список с начала:", numbers_list)
#     elif choice == "конец":
#         print("Список с конца:", numbers_list[::-1])
#     else:
#         print("Неверный выбор!")

# def check_number(numbers_list):
#     try:
#         num = int(input("Введите число для поиска: "))
#         if num in numbers_list:
#             print(f"Число {num} присутствует в списке.")
#         else:
#             print(f"Число {num} не найдено.")
#     except ValueError:
#         print("Введите корректное число.")

# def replace_number(numbers_list):
#     try:
#         num = int(input("Введите число, которое хотите заменить: "))
#         new_num = int(input("Введите новое число: "))
#         replace_choice = input("Заменить первое вхождение или все? (введите 'первое' или 'все'): ").strip().lower()

#         if replace_choice == "первое":
#             for i in range(len(numbers_list)):
#                 if numbers_list[i] == num:
#                     numbers_list[i] = new_num
#                     print(f"Первое вхождение числа {num} заменено на {new_num}.")
#                     break
#             else:
#                 print(f"Число {num} не найдено в списке.")
#         elif replace_choice == "все":
#             count = numbers_list.count(num)
#             if count > 0:
#                 numbers_list[:] = [new_num if x == num else x for x in numbers_list]
#                 print(f"Все вхождения числа {num} заменены на {new_num}.")
#             else:
#                 print(f"Число {num} не найдено в списке.")
#         else:
#             print("Неверный выбор.")
#     except ValueError:
#         print("Введите корректное число.")

# def main():
#     numbers_list = []

#     while True:
#         print_menu()
#         choice = input("\nВыберите пункт меню: ")

#         if choice == "1":
#             add_number(numbers_list)
#         elif choice == "2":
#             remove_number(numbers_list)
#         elif choice == "3":
#             show_list(numbers_list)
#         elif choice == "4":
#             check_number(numbers_list)
#         elif choice == "5":
#             replace_number(numbers_list)
#         elif choice == "6":
#             print("Выход из программы.")
#             break
#         else:
#             print("Неверный выбор, попробуйте снова.")

# if __name__ == "__main__":
#     main()









# Основное меню (print_menu)

# Функция print_menu() выводит список опций, доступных пользователю. Это удобный способ навигации, так как каждая операция имеет свой номер.
# Выбор пункта меню происходит через ввод пользователя, программа будет запрашивать его выбор и выполнять соответствующие действия.
# Добавление нового числа в список (add_number)







# Пользователь вводит число через клавиатуру. Программа проверяет, есть ли уже это число в списке. Если да — выводит сообщение, что добавление невозможно.
# Если такого числа нет, оно добавляется в список, и программа сообщает об этом.
# Удаление всех вхождений числа из списка (remove_number)







# Пользователь вводит число, которое нужно удалить.
# Для удаления используется генератор списка, который оставляет только те элементы, которые не равны введённому числу. Таким образом удаляются все вхождения числа.
# Показ содержимого списка (show_list)






# Программа предлагает пользователю выбрать, как показывать список — с начала или с конца.
# Если выбран показ "с начала", выводится список в его текущем виде. Если "с конца" — программа использует срез [::-1], чтобы отобразить список в обратном порядке.
# Проверка наличия числа в списке (check_number)







# Пользователь вводит число, и программа проверяет, есть ли оно в списке.
# Если число найдено, выводится соответствующее сообщение. Если нет — программа сообщает, что числа в списке нет.
# Замена числа в списке (replace_number)






# Пользователь может заменить одно или несколько вхождений определённого числа в списке.
# Если выбрано "первое" вхождение, программа проходит по списку и заменяет только первый найденный элемент. Если выбрано "все", программа заменяет все вхождения числа.
# Для замены всех элементов используется генератор списка.
# Главная функция (main)









# В main() реализован бесконечный цикл, который постоянно показывает меню и обрабатывает выбор пользователя. Это позволяет пользователю выполнять различные операции, пока он не выберет пункт "Выход".
# Программа проверяет каждый ввод пользователя, и в зависимости от выбора вызывает соответствующую функцию.
# Обработка ошибок







# В функциях add_number, remove_number, check_number, replace_number предусмотрена обработка ошибок при вводе. Например, если пользователь вводит не число, программа не завершится аварийно, а покажет сообщение об ошибке и предложит ввести данные снова.


















# Задание 2
# Реализуйте класс стека для работы со строками (стек
# строк).
# Стек должен иметь фиксированный размер.
# Реализуйте набор операций для работы со стеком:
# ■ помещение строки в стек;
# ■ выталкивание строки из стека;
# ■ подсчет количества строк в стеке;
# ■ проверку пустой ли стек;
# ■ проверку полный ли стек;
# ■ очистку стека;
# ■ получение значения без выталкивания верхней строки
# из стека.
# При старте приложения нужно отобразить меню с
# помощью, которого пользователь может выбрать необ-
# ходимую операцию.







# class StringStack:
#     def __init__(self, size):
#         self.size = size
#         self.stack = []

#     def push(self, string):
#         if self.is_full():
#             print("Стек полный! Невозможно добавить строку.")
#         else:
#             self.stack.append(string)
#             print(f"Строка '{string}' добавлена в стек.")

#     def pop(self):
#         if self.is_empty():
#             print("Стек пуст! Невозможно извлечь строку.")
#         else:
#             removed_string = self.stack.pop()
#             print(f"Строка '{removed_string}' извлечена из стека.")

#     def count(self):
#         return len(self.stack)

#     def is_empty(self):
#         return len(self.stack) == 0

#     def is_full(self):
#         return len(self.stack) == self.size

#     def clear(self):
#         self.stack.clear()
#         print("Стек очищен.")

#     def peek(self):
#         if self.is_empty():
#             print("Стек пуст! Невозможно получить верхнюю строку.")
#         else:
#             return self.stack[-1]

# def print_menu():
#     print("\nМеню:")
#     print("1. Поместить строку в стек")
#     print("2. Вытолкнуть строку из стека")
#     print("3. Подсчитать количество строк в стеке")
#     print("4. Проверить, пустой ли стек")
#     print("5. Проверить, полный ли стек")
#     print("6. Очистить стек")
#     print("7. Получить верхнюю строку из стека")
#     print("8. Выход")

# def main():
#     size = int(input("Введите максимальный размер стека: "))
#     string_stack = StringStack(size)

#     while True:
#         print_menu()
#         choice = input("\nВыберите пункт меню: ")

#         if choice == "1":
#             string_to_push = input("Введите строку для добавления в стек: ")
#             string_stack.push(string_to_push)
#         elif choice == "2":
#             string_stack.pop()
#         elif choice == "3":
#             print(f"Количество строк в стеке: {string_stack.count()}")
#         elif choice == "4":
#             if string_stack.is_empty():
#                 print("Стек пуст.")
#             else:
#                 print("Стек не пуст.")
#         elif choice == "5":
#             if string_stack.is_full():
#                 print("Стек полный.")
#             else:
#                 print("Стек не полный.")
#         elif choice == "6":
#             string_stack.clear()
#         elif choice == "7":
#             top_string = string_stack.peek()
#             if top_string is not None:
#                 print(f"Верхняя строка в стеке: '{top_string}'")
#         elif choice == "8":
#             print("Выход из программы.")
#             break
#         else:
#             print("Неверный выбор, попробуйте снова.")

# if __name__ == "__main__":
#     main()







# Класс стека (StringStack)

# __init__: Инициализация стека с заданным размером. Создаётся пустой список stack, который будет хранить строки.

# push(self, string): Метод для добавления строки в стек. Проверяется, полон ли стек. Если да, выводится сообщение об ошибке, если нет — строка добавляется.

# pop(self): Метод для удаления верхней строки из стека. Проверяется, пуст ли стек. Если да, выводится сообщение об ошибке, если нет — строка извлекается и выводится на экран.

# count(self): Метод возвращает количество строк в стеке, используя встроенную функцию len().

# is_empty(self): Метод проверяет, пуст ли стек, и возвращает True или False.

# is_full(self): Метод проверяет, полон ли стек, и возвращает True или False.

# clear(self): Метод очищает стек, используя метод clear() списка.

# peek(self): Метод возвращает верхнюю строку в стеке без её удаления. Если стек пуст, выводится сообщение об ошибке.







# Основное меню (print_menu)
# Функция print_menu() выводит список опций, доступных пользователю для работы со стеком.
# Главная функция (main)





# В main() запрашивается максимальный размер стека и создаётся объект класса StringStack.
# Реализован бесконечный цикл, который постоянно показывает меню и обрабатывает выбор пользователя. В зависимости от выбора вызывается соответствующий метод стека.
# Программа проверяет ввод пользователя и в зависимости от выбора вызывает соответствующую функцию.
# Обработка ошибок

# В методах push, pop и peek предусмотрена обработка ошибок при пустом или полном стеке. Программа не завершится аварийно, а выдаст соответствующие сообщения.
















# Задание 3
# Измените стек из второго задания, таким образом,
# чтобы его размер был нефиксированным.



# class DynamicStringStack:
#     def __init__(self):
#         self.stack = []

#     def push(self, string):
#         self.stack.append(string)
#         print(f"Строка '{string}' добавлена в стек.")

#     def pop(self):
#         if self.is_empty():
#             print("Стек пуст! Невозможно извлечь строку.")
#         else:
#             removed_string = self.stack.pop()
#             print(f"Строка '{removed_string}' извлечена из стека.")

#     def count(self):
#         return len(self.stack)

#     def is_empty(self):
#         return len(self.stack) == 0

#     def clear(self):
#         self.stack.clear()
#         print("Стек очищен.")

#     def peek(self):
#         if self.is_empty():
#             print("Стек пуст! Невозможно получить верхнюю строку.")
#         else:
#             return self.stack[-1]

# def print_menu():
#     print("\nМеню:")
#     print("1. Поместить строку в стек")
#     print("2. Вытолкнуть строку из стека")
#     print("3. Подсчитать количество строк в стеке")
#     print("4. Проверить, пустой ли стек")
#     print("5. Очистить стек")
#     print("6. Получить верхнюю строку из стека")
#     print("7. Выход")

# def main():
#     string_stack = DynamicStringStack()

#     while True:
#         print_menu()
#         choice = input("\nВыберите пункт меню: ")

#         if choice == "1":
#             string_to_push = input("Введите строку для добавления в стек: ")
#             string_stack.push(string_to_push)
#         elif choice == "2":
#             string_stack.pop()
#         elif choice == "3":
#             print(f"Количество строк в стеке: {string_stack.count()}")
#         elif choice == "4":
#             if string_stack.is_empty():
#                 print("Стек пуст.")
#             else:
#                 print("Стек не пуст.")
#         elif choice == "5":
#             string_stack.clear()
#         elif choice == "6":
#             top_string = string_stack.peek()
#             if top_string is not None:
#                 print(f"Верхняя строка в стеке: '{top_string}'")
#         elif choice == "7":
#             print("Выход из программы.")
#             break
#         else:
#             print("Неверный выбор, попробуйте снова.")

# if __name__ == "__main__":
#     main()









# Класс динамического стека (DynamicStringStack)

# __init__: Конструктор класса, инициализирующий пустой стек с помощью списка self.stack, который будет хранить строки. Поскольку мы используем список, размер стека будет автоматически изменяться в зависимости от количества элементов.

# push(self, string): Метод для добавления строки в стек. Добавляет строку в конец списка, что также означает, что она становится верхней строкой стека.

# pop(self): Метод для удаления верхней строки из стека. Проверяет, пуст ли стек, и если нет, удаляет и возвращает верхнюю строку. Если стек пуст, выводит сообщение об ошибке.
# count(self): Метод возвращает количество строк в стеке, используя встроенную функцию len().

# is_empty(self): Метод проверяет, пуст ли стек, возвращая True, если он пуст, и False в противном случае.

# clear(self): Метод очищает стек, используя метод clear() списка, который удаляет все элементы.

# peek(self): Метод возвращает верхнюю строку в стеке без её удаления. Если стек пуст, выводится сообщение об ошибке.
# Меню (print_menu)







# Функция print_menu() выводит список доступных опций для пользователя, чтобы взаимодействовать со стеком.
# Основная функция (main)

# В функции main() создаётся объект класса DynamicStringStack.
# Запускается бесконечный цикл, который отображает меню и обрабатывает выбор пользователя. В зависимости от выбора вызывается соответствующий метод класса DynamicStringStack.
# Программа проверяет ввод пользователя и при необходимости вызывает соответствующую функцию.
# Обработка ошибок

# В методах pop и peek предусмотрена обработка ошибок при попытке работать с пустым стеком. Это позволяет избежать аварийных завершений программы и информировать пользователя об ошибках.











# Модуль 15 Модульное тестирование
# Тема: Модульное тестирование

# Введение:
# Модульное тестирование (unit testing) — это процесс проверки отдельных компонентов (модулей) программы на корректность работы.
# В контексте программирования модуль может быть функцией, методом, классом или любым другим минимальным функциональным блоком.
# Модульное тестирование помогает убедиться, что каждый отдельный компонент работает так, как ожидается,
# и позволяет выявить ошибки на ранних стадиях разработки.

# Зачем нужно модульное тестирование?
# Раннее выявление ошибок: Модульное тестирование позволяет обнаружить ошибки на ранних стадиях разработки,
# что делает их исправление проще и дешевле.
# Улучшение качества кода: Писание тестов заставляет разработчиков думать о возможных ошибках и исключительных ситуациях, 
# что улучшает общий дизайн и качество кода.
# Легкость изменений: Когда у вас есть набор тестов, вы можете вносить изменения в код с уверенностью, что если что-то сломается,
# тесты это обнаружат.







# Документация: Тесты могут служить живой документацией кода, показывая, как он должен использоваться и какие результаты ожидать.
# Основные понятия
# Тестовый случай (Test Case): Набор условий или переменных, под которыми проверяется корректность работы кода.

# Тестовый метод (Test Method): Функция, которая проверяет конкретное поведение кода.

# Тестовый набор (Test Suite): Группа тестов, которые запускаются вместе.

# Тестовый раннер (Test Runner): Инструмент, который выполняет тесты и сообщает о результатах.










# Модульное тестирование в Python
# Python предоставляет встроенный модуль unittest для модульного тестирования, 
# который поддерживает создание, запуск и отчет о результатах тестов. 
# Давайте рассмотрим основные компоненты модульного тестирования в Python.











# Основы использования unittest

# Создание тестового случая
# Для создания тестового случая необходимо создать класс, наследующийся от unittest.TestCase, 
# и определить в нем методы, начинающиеся с test_.


# import unittest

# class TestMathOperations(unittest.TestCase):

#     def test_addition(self):
#         self.assertEqual(1 + 1, 2)

#     def test_subtraction(self):
#         self.assertEqual(5 - 3, 2)

# if __name__ == '__main__':
#     unittest.main()






Запуск тестов
Для запуска тестов используется метод unittest.main(),
который автоматически находит все методы, начинающиеся с test_, и выполняет их.










Основные методы утверждений (Assertions)
Утверждения используются для проверки, соответствует ли результат выполнения кода ожидаемому значению.

assertEqual(a, b): Проверяет, что a == b.

assertNotEqual(a, b): Проверяет, что a != b.

assertTrue(x): Проверяет, что x истинно.

assertFalse(x): Проверяет, что x ложно.

assertIs(a, b): Проверяет, что a и b — это один и тот же объект.

assertIsNot(a, b): Проверяет, что a и b — это не один и тот же объект.

assertIsNone(x): Проверяет, что x равно None.

assertIsNotNone(x): Проверяет, что x не равно None.

assertIn(a, b): Проверяет, что a содержится в b.

assertNotIn(a, b): Проверяет, что a не содержится в b.













Организация тестов
Использование setUp и tearDown
Методы setUp и tearDown используются для подготовки и очистки среды перед и после каждого теста соответственно.


import unittest

class TestMathOperations(unittest.TestCase):

    def setUp(self):
        # Подготовка перед каждым тестом
        self.a = 10
        self.b = 5

    def tearDown(self):
        # Очистка после каждого теста
        pass

    def test_addition(self):
        self.assertEqual(self.a + self.b, 15)

    def test_subtraction(self):
        self.assertEqual(self.a - self.b, 5)

if __name__ == '__main__':
    unittest.main()












Тестовые наборы (Test Suites)
Тестовые наборы позволяют группировать тесты и запускать их вместе.







import unittest

class TestMathOperations(unittest.TestCase):

    def test_addition(self):
        self.assertEqual(1 + 1, 2)

    def test_subtraction(self):
        self.assertEqual(5 - 3, 2)

class TestStringOperations(unittest.TestCase):

    def test_concatenation(self):
        self.assertEqual('a' + 'b', 'ab')

    def test_uppercase(self):
        self.assertEqual('a'.upper(), 'A')

# Создание тестового набора
suite = unittest.TestSuite()
suite.addTest(unittest.makeSuite(TestMathOperations))
suite.addTest(unittest.makeSuite(TestStringOperations))

# Запуск тестового набора
runner = unittest.TextTestRunner()
runner.run(suite)







Заключение:
Модульное тестирование является важнейшим аспектом разработки программного обеспечения, 
позволяя гарантировать корректность и стабильность кода. 
Python предоставляет мощный инструментарий для модульного тестирования через модуль unittest, 
который позволяет создавать, запускать и отчитываться о результатах тестов. Используя модульное тестирование,
вы можете улучшить качество вашего кода, выявлять ошибки на ранних стадиях и упростить процесс разработки.




# Задание 1
# Создайте класс, содержащий набор целых чисел.
# ональность:
# ■ Сумма элементов набора.
# ■ Среднеарифметическое элементов набора.
# ■ Максимум из элементов набора.
# ■ Минимум из элементов набора.
# Протестируйте все возможности созданного класса
# с помощью модульного тестирования(unittest).



# 1. Класс для набора целых чисел

# class IntegerSet:
#     def __init__(self, numbers):
#         # Инициализируем набор целых чисел
#         self.numbers = numbers

#     def sum(self):
#         # Возвращает сумму элементов набора
#         return sum(self.numbers)

#     def average(self):
#         # Возвращает среднеарифметическое элементов набора
#         if len(self.numbers) == 0:
#             return 0
#         return sum(self.numbers) / len(self.numbers)

#     def maximum(self):
#         # Возвращает максимальный элемент из набора
#         if len(self.numbers) == 0:
#             return None
#         return max(self.numbers)

#     def minimum(self):
#         # Возвращает минимальный элемент из набора
#         if len(self.numbers) == 0:
#             return None
#         return min(self.numbers)



# 2. Модульное тестирование с использованием unittest

# import unittest

# class TestIntegerSet(unittest.TestCase):
    
#     def setUp(self):
#         # Инициализация перед каждым тестом
#         self.integer_set = IntegerSet([10, 20, 30, 40, 50])

#     def test_sum(self):
#         # Тестирование метода суммы
#         self.assertEqual(self.integer_set.sum(), 150)

#     def test_average(self):
#         # Тестирование метода среднего арифметического
#         self.assertEqual(self.integer_set.average(), 30)

#     def test_maximum(self):
#         # Тестирование метода для нахождения максимума
#         self.assertEqual(self.integer_set.maximum(), 50)

#     def test_minimum(self):
#         # Тестирование метода для нахождения минимума
#         self.assertEqual(self.integer_set.minimum(), 10)

#     def test_empty_set(self):
#         # Тестирование методов для пустого набора
#         empty_set = IntegerSet([])
#         self.assertEqual(empty_set.sum(), 0)
#         self.assertEqual(empty_set.average(), 0)
#         self.assertIsNone(empty_set.maximum())
#         self.assertIsNone(empty_set.minimum())

# if __name__ == '__main__':
#     unittest.main()






# Объяснение работы кода:
# Класс IntegerSet:

# Конструктор (__init__): Принимает список целых чисел и сохраняет его в атрибуте self.numbers.

# Метод sum(): Возвращает сумму элементов набора с использованием функции sum().

# Метод average(): Вычисляет среднеарифметическое значение. Если набор пуст, возвращает 0.

# Метод maximum(): Возвращает максимальное число из набора. Если набор пуст, возвращает None.

# Метод minimum(): Возвращает минимальное число из набора. Если набор пуст, возвращает None.





# Модульное тестирование (unittest):
# Тесты проверяют корректность работы методов класса IntegerSet.
# setUp(): Этот метод вызывается перед каждым тестом для создания экземпляра класса IntegerSet с предустановленным набором чисел.
# Тесты (test_sum(), test_average(), test_maximum(), test_minimum()): Проверяют, возвращают ли методы ожидаемые значения.
# Тест для пустого набора (test_empty_set()): Проверяет, как методы ведут себя с пустым набором.



# Как работает программа:
# Программа создаёт экземпляр класса IntegerSet, который хранит целые числа.
# Каждый метод класса выполняет своё действие (например, вычисление суммы или нахождение максимума).
# Модульные тесты проверяют работу методов, выполняя заранее запланированные проверки на различных входных данных.